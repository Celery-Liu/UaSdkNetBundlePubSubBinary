/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.7.0, using .NET Server 4.1.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2024 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://www.unifiedautomation.com/DemoServer/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Created: 16.08.2024
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using UnifiedAutomation.UaBase;
using UnifiedAutomation.UaServer;

namespace UnifiedAutomation.Demo.Model
{
    #region BoilerModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.BoilerType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class BoilerModel : BaseObjectModel, IMethodDispatcher
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="BoilerModel" /> class.
        /// </summary>
        public BoilerModel() : this((BoilerModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BoilerModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public BoilerModel(BoilerModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                FillLevelSensor = new FillLevelSensorModel();
                TemperatureSensor = new TemperatureSensorModel();
            }
            else
            {
                FillLevelSensor = new FillLevelSensorModel(template.FillLevelSensor);
                FillLevelSetPoint = template.FillLevelSetPoint;
                HeaterStatus = template.HeaterStatus;
                TemperatureSensor = new TemperatureSensorModel(template.TemperatureSensor);
                TemperatureSetPoint = template.TemperatureSetPoint;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the FillLevelSensor
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public FillLevelSensorModel FillLevelSensor { get; set; }

        /// <summary>
        /// Gets or sets the FillLevelSetPoint
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public double FillLevelSetPoint
        {
            get => m_FillLevelSetPoint;
            set => SetField(ref m_FillLevelSetPoint, value, nameof(FillLevelSetPoint));
        }
        private double m_FillLevelSetPoint;

        /// <summary>
        /// Gets or sets the HeaterStatus
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public HeaterStatus HeaterStatus
        {
            get => m_HeaterStatus;
            set => SetField(ref m_HeaterStatus, value, nameof(HeaterStatus));
        }
        private HeaterStatus m_HeaterStatus;

        /// <summary>
        /// Gets or sets the TemperatureSensor
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public TemperatureSensorModel TemperatureSensor { get; set; }

        /// <summary>
        /// Gets or sets the TemperatureSetPoint
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public double TemperatureSetPoint
        {
            get => m_TemperatureSetPoint;
            set => SetField(ref m_TemperatureSetPoint, value, nameof(TemperatureSetPoint));
        }
        private double m_TemperatureSetPoint;


        #endregion
        #region IMethodDispatcher Members
        /// <summary>
        /// Gets the method dispatcher.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="objectId">The object id.</param>
        /// <param name="methodId">The method id.</param>
        /// <returns></returns>
        public virtual CallMethodEventHandler GetMethodDispatcher(
            RequestContext context,
            NodeId objectId,
            NodeId methodId)
        {
            return DispatchMethod;
        }

        /// <summary>
        /// Gets the async method dispatcher.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="objectId">The object id.</param>
        /// <param name="methodId">The method id.</param>
        /// <returns></returns>
        public virtual CallAsyncMethodEventHandler GetAsyncMethodDispatcher(
            RequestContext context,
            NodeId objectId,
            NodeId methodId)
        {
            return DispatchMethodAsync;
        }
        #endregion

        #region Public Methods

        /// <summary>
        /// Dispatches the method.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="methodHandle">The method handle.</param>
        /// <param name="inputArguments">The input arguments.</param>
        /// <param name="inputArgumentResults">The input argument results.</param>
        /// <param name="outputArguments">The output arguments.</param>
        /// <returns></returns>
        public virtual StatusCode DispatchMethod(
            RequestContext context,
            MethodHandle methodHandle,
            IList<Variant> inputArguments,
            List<StatusCode> inputArgumentResults,
            List<Variant> outputArguments)
        {
            IBoilerMethods implemention = BoilerMethods;

            if (implemention == null)
            {
                implemention = this as IBoilerMethods;
            }

            if (implemention == null)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            ExpandedNodeId methodDeclarationId = NodeId.ToAbsoluteNodeId(methodHandle.MethodDeclarationId, context.NamespaceUris);

            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.BoilerType_Fill)
            {
                StatusCode ret = implemention.Fill(context, this, inputArguments[0].ToDouble());
                if (ret.IsGood())
                {
                }
                return ret;

            }
            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.BoilerType_Heat)
            {
                StatusCode ret = implemention.Heat(context, this, inputArguments[0].ToDouble());
                if (ret.IsGood())
                {
                }
                return ret;

            }
            return StatusCodes.BadMethodInvalid;
        }

        /// <summary>
        /// Gets or sets the Boiler methods.
        /// </summary>
        /// <value>
        /// The Boiler methods.
        /// </value>
        public IBoilerMethods BoilerMethods { get; set; }

        /// <summary>
        /// Gets or sets the Boiler async methods.
        /// </summary>
        /// <value>
        /// The Boiler async methods.
        /// </value>
        public IBoilerAsyncMethods BoilerAsyncMethods { get; set; }

        /// <summary>
        /// Dispatches the method.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="methodHandle">The method handle.</param>
        /// <param name="inputArguments">The input arguments.</param>
        /// <returns></returns>
        public async virtual Task<CallMethodResult> DispatchMethodAsync(
            RequestContext context,
            MethodHandle methodHandle,
            IList<Variant> inputArguments)
        {
            IBoilerAsyncMethods implementation = BoilerAsyncMethods ?? this as IBoilerAsyncMethods;

            StatusCode ret;
            StatusCodeCollection inputArgumentResults = new StatusCodeCollection();
            VariantCollection outputArguments = new VariantCollection();
            ExpandedNodeId methodDeclarationId = NodeId.ToAbsoluteNodeId(methodHandle.MethodDeclarationId, context.NamespaceUris);

            if (implementation == null)
            {
                ret = StatusCodes.BadNotImplemented;
            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.BoilerType_Fill)
            {
                ret = await implementation.FillAsync(context, this, inputArguments[0].ToDouble(), context.CancellationToken).ConfigureAwait(false);

            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.BoilerType_Heat)
            {
                ret = await implementation.HeatAsync(context, this, inputArguments[0].ToDouble(), context.CancellationToken).ConfigureAwait(false);

            }
            else
            {
                ret = StatusCodes.BadMethodInvalid;
            }

            return new CallMethodResult()
            {
                StatusCode = ret,
                InputArgumentResults = inputArgumentResults,
                OutputArguments = outputArguments
            };

        }
        #endregion
    }

    /// <summary>
    /// The interface for methods implemented on the BoilerModel object.
    /// </summary>
    public interface IBoilerMethods
    {
        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="SetPoint">FillLevel Setpoint [l]</param>
        /// <returns></returns>
        StatusCode Fill(
            RequestContext context,
            BoilerModel model,
            double SetPoint
            );

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="SetPoint">Temperature Setpoint [\302\260C]</param>
        /// <returns></returns>
        StatusCode Heat(
            RequestContext context,
            BoilerModel model,
            double SetPoint
            );

    }


    /// <summary>
    /// The interface for async methods implemented on the BoilerModel object.
    /// </summary>
    public interface IBoilerAsyncMethods
    {
        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="SetPoint">FillLevel Setpoint [l]</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> FillAsync(
            RequestContext context,
            BoilerModel model,
            double SetPoint,
            CancellationToken cancellationToken);

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="SetPoint">Temperature Setpoint [\302\260C]</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> HeatAsync(
            RequestContext context,
            BoilerModel model,
            double SetPoint,
            CancellationToken cancellationToken);


    }
    #endregion


    #region FillLevelSensorModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.FillLevelSensorType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class FillLevelSensorModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="FillLevelSensorModel" /> class.
        /// </summary>
        public FillLevelSensorModel() : this((FillLevelSensorModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FillLevelSensorModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public FillLevelSensorModel(FillLevelSensorModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                FillLevel = new AnalogItemModel<double>();
            }
            else
            {
                FillLevel = new AnalogItemModel<double>(template.FillLevel);
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the FillLevel
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public AnalogItemModel<double> FillLevel { get; set; }


        #endregion
    }
    #endregion


    #region MachineModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class MachineModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineModel" /> class.
        /// </summary>
        public MachineModel() : this((MachineModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineModel(MachineModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                TemperatureSensor = new TemperatureSensorModel();
            }
            else
            {
                HeaterSwitch = template.HeaterSwitch;
                TemperatureSensor = new TemperatureSensorModel(template.TemperatureSensor);
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the HeaterSwitch
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public bool HeaterSwitch
        {
            get => m_HeaterSwitch;
            set => SetField(ref m_HeaterSwitch, value, nameof(HeaterSwitch));
        }
        private bool m_HeaterSwitch;

        /// <summary>
        /// Gets or sets the TemperatureSensor
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public TemperatureSensorModel TemperatureSensor { get; set; }


        #endregion
    }
    #endregion


    #region CountdownStateMachineModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.CountdownStateMachineType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class CountdownStateMachineModel : ProgramStateMachineModel, IMethodDispatcher, IActivatableModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="CountdownStateMachineModel" /> class.
        /// </summary>
        public CountdownStateMachineModel() : this((CountdownStateMachineModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CountdownStateMachineModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public CountdownStateMachineModel(CountdownStateMachineModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                Value = template.Value;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Value
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public double Value
        {
            get => m_Value;
            set => SetField(ref m_Value, value, nameof(Value));
        }
        private double m_Value;


        #endregion

        #region FiniteStateMachine

        /// <remarks />
        public NamespaceTable NamespaceTable { get; set; }

        /// <remarks />
        public virtual void ActivateModel(RequestContext context)
        {
            NamespaceTable = context.NamespaceUris;

            // reset state and transition with the now available Ids
            InternalState = m_state;
            InternalTransition = m_transition;
        }

        /// <remarks />
        public virtual void DeactivateModel()
        {
        }

        /// <summary>
        /// Switch to the given state.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <param name="transition">The transition.</param>
        /// <remarks>
        /// If the transition value is <c>null</c> the method will take the first
        /// transition that is possible. If there is no possible transition or
        /// if a transition was passed that is not possible for the old and new
        /// state combination, <c>null</c> will be assigned to the
        /// <see cref="InternalTransition"/> and <see cref="FiniteStateMachineModel.LastTransition"/> properties.
        /// It is up to the caller to avoid such situations.
        ///
        /// A <c>null</c> value for the state will be translated to the specification
        /// conform status code <see cref="StatusCodes.BadStateNotActive"/>.
        /// </remarks>
        public override void SwitchToState(State? state, Transition? transition = null)
        {
            State? oldState = InternalState;

            if (oldState.HasValue && state.HasValue)
            {
                var transitions = GetTransitions(oldState.Value, state.Value);
                if (transition.HasValue)
                {
                    var tvalue = transition.Value;
                    transitions = transitions.Where(t => t == tvalue);
                }

                transition = transitions
                    .Cast<Transition?>()
                    .FirstOrDefault();
            }

            InternalState = state;
            InternalTransition = transition;

            RaiseSwitchedEvent(oldState, state, transition);
        }

        #endregion

        #region IMethodDispatcher Members
        /// <summary>
        /// Gets the method dispatcher.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="objectId">The object id.</param>
        /// <param name="methodId">The method id.</param>
        /// <returns></returns>
        public virtual CallMethodEventHandler GetMethodDispatcher(
            RequestContext context,
            NodeId objectId,
            NodeId methodId)
        {
            return DispatchMethod;
        }

        /// <summary>
        /// Gets the async method dispatcher.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="objectId">The object id.</param>
        /// <param name="methodId">The method id.</param>
        /// <returns></returns>
        public virtual CallAsyncMethodEventHandler GetAsyncMethodDispatcher(
            RequestContext context,
            NodeId objectId,
            NodeId methodId)
        {
            return DispatchMethodAsync;
        }
        #endregion

        #region Public Methods

        /// <summary>
        /// Dispatches the method.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="methodHandle">The method handle.</param>
        /// <param name="inputArguments">The input arguments.</param>
        /// <param name="inputArgumentResults">The input argument results.</param>
        /// <param name="outputArguments">The output arguments.</param>
        /// <returns></returns>
        public virtual StatusCode DispatchMethod(
            RequestContext context,
            MethodHandle methodHandle,
            IList<Variant> inputArguments,
            List<StatusCode> inputArgumentResults,
            List<Variant> outputArguments)
        {
            ICountdownStateMachineMethods implemention = CountdownStateMachineMethods;

            if (implemention == null)
            {
                implemention = this as ICountdownStateMachineMethods;
            }

            if (implemention == null)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            ExpandedNodeId methodDeclarationId = NodeId.ToAbsoluteNodeId(methodHandle.MethodDeclarationId, context.NamespaceUris);

            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Halt)
            {
                StatusCode ret = implemention.Halt(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Reset)
            {
                StatusCode ret = implemention.Reset(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Resume)
            {
                StatusCode ret = implemention.Resume(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Start)
            {
                StatusCode ret = implemention.Start(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Suspend)
            {
                StatusCode ret = implemention.Suspend(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            return StatusCodes.BadMethodInvalid;
        }

        /// <summary>
        /// Gets or sets the CountdownStateMachine methods.
        /// </summary>
        /// <value>
        /// The CountdownStateMachine methods.
        /// </value>
        public ICountdownStateMachineMethods CountdownStateMachineMethods { get; set; }

        /// <summary>
        /// Gets or sets the CountdownStateMachine async methods.
        /// </summary>
        /// <value>
        /// The CountdownStateMachine async methods.
        /// </value>
        public ICountdownStateMachineAsyncMethods CountdownStateMachineAsyncMethods { get; set; }

        /// <summary>
        /// Dispatches the method.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="methodHandle">The method handle.</param>
        /// <param name="inputArguments">The input arguments.</param>
        /// <returns></returns>
        public async virtual Task<CallMethodResult> DispatchMethodAsync(
            RequestContext context,
            MethodHandle methodHandle,
            IList<Variant> inputArguments)
        {
            ICountdownStateMachineAsyncMethods implementation = CountdownStateMachineAsyncMethods ?? this as ICountdownStateMachineAsyncMethods;

            StatusCode ret;
            StatusCodeCollection inputArgumentResults = new StatusCodeCollection();
            VariantCollection outputArguments = new VariantCollection();
            ExpandedNodeId methodDeclarationId = NodeId.ToAbsoluteNodeId(methodHandle.MethodDeclarationId, context.NamespaceUris);

            if (implementation == null)
            {
                ret = StatusCodes.BadNotImplemented;
            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Halt)
            {
                ret = await implementation.HaltAsync(context, this, context.CancellationToken).ConfigureAwait(false);

            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Reset)
            {
                ret = await implementation.ResetAsync(context, this, context.CancellationToken).ConfigureAwait(false);

            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Resume)
            {
                ret = await implementation.ResumeAsync(context, this, context.CancellationToken).ConfigureAwait(false);

            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Start)
            {
                ret = await implementation.StartAsync(context, this, context.CancellationToken).ConfigureAwait(false);

            }
            else if (methodDeclarationId == UnifiedAutomation.Demo.Model.MethodIds.CountdownStateMachineType_Suspend)
            {
                ret = await implementation.SuspendAsync(context, this, context.CancellationToken).ConfigureAwait(false);

            }
            else
            {
                ret = StatusCodes.BadMethodInvalid;
            }

            return new CallMethodResult()
            {
                StatusCode = ret,
                InputArgumentResults = inputArgumentResults,
                OutputArguments = outputArguments
            };

        }
        #endregion
    }

    /// <summary>
    /// The interface for methods implemented on the CountdownStateMachineModel object.
    /// </summary>
    public interface ICountdownStateMachineMethods
    {
        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode Halt(
            RequestContext context,
            CountdownStateMachineModel model
            );

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode Reset(
            RequestContext context,
            CountdownStateMachineModel model
            );

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode Resume(
            RequestContext context,
            CountdownStateMachineModel model
            );

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode Start(
            RequestContext context,
            CountdownStateMachineModel model
            );

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode Suspend(
            RequestContext context,
            CountdownStateMachineModel model
            );

    }


    /// <summary>
    /// The interface for async methods implemented on the CountdownStateMachineModel object.
    /// </summary>
    public interface ICountdownStateMachineAsyncMethods
    {
        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> HaltAsync(
            RequestContext context,
            CountdownStateMachineModel model,
            CancellationToken cancellationToken);

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> ResetAsync(
            RequestContext context,
            CountdownStateMachineModel model,
            CancellationToken cancellationToken);

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> ResumeAsync(
            RequestContext context,
            CountdownStateMachineModel model,
            CancellationToken cancellationToken);

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> StartAsync(
            RequestContext context,
            CountdownStateMachineModel model,
            CancellationToken cancellationToken);

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<StatusCode> SuspendAsync(
            RequestContext context,
            CountdownStateMachineModel model,
            CancellationToken cancellationToken);


    }
    #endregion


    #region TemperatureSensorModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.TemperatureSensorType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class TemperatureSensorModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="TemperatureSensorModel" /> class.
        /// </summary>
        public TemperatureSensorModel() : this((TemperatureSensorModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TemperatureSensorModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public TemperatureSensorModel(TemperatureSensorModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                Temperature = new AnalogItemModel<double>();
            }
            else
            {
                Temperature = new AnalogItemModel<double>(template.Temperature);
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Temperature
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public AnalogItemModel<double> Temperature { get; set; }


        #endregion
    }
    #endregion


    #region SampleEventModel
    /// <summary>
    /// An event type that contains all datatypes as event fields.
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.SampleEventType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class SampleEventModel : BaseEventModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="SampleEventModel" /> class.
        /// </summary>
        public SampleEventModel() : this((SampleEventModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SampleEventModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        public SampleEventModel(SampleEventModel template) : base(template)
        {
            m_FieldHandles = (template != null) ? template.m_FieldHandles : null;

            if (template == null)
            {
            }
            else
            {
                Boolean = template.Boolean;
                Byte = template.Byte;
                ByteString = template.ByteString == null ? null : template.ByteString.Clone() as byte[];
                DateTime = template.DateTime;
                Double = template.Double;
                Enumeration = template.Enumeration;
                ExpandedNodeId = template.ExpandedNodeId == null ? null : template.ExpandedNodeId.Clone() as ExpandedNodeId;
                Float = template.Float;
                Guid = template.Guid;
                Int16 = template.Int16;
                Int32 = template.Int32;
                Int64 = template.Int64;
                LocalizedText = template.LocalizedText == null ? null : template.LocalizedText.Clone() as LocalizedText;
                NodeIdNode = template.NodeIdNode == null ? null : template.NodeIdNode.Clone() as NodeId;
                OptionSetBase = template.OptionSetBase == null ? null : template.OptionSetBase.Clone() as OptionSetBase;
                OptionSetBaseArray = template.OptionSetBaseArray == null ? null : template.OptionSetBaseArray.Clone() as OptionSetBase[];
                OptionSetByte = template.OptionSetByte;
                OptionSetUInt16 = template.OptionSetUInt16;
                OptionSetUInt16Array = template.OptionSetUInt16Array == null ? null : template.OptionSetUInt16Array.Clone() as OptionSetUInt16[];
                OptionSetUInt32 = template.OptionSetUInt32;
                OptionSetUInt64 = template.OptionSetUInt64;
                QualifiedName = template.QualifiedName == null ? null : template.QualifiedName.Clone() as QualifiedName;
                SByte = template.SByte;
                StatusCode = template.StatusCode;
                String = template.String == null ? null : template.String.Clone() as string;
                Structure = template.Structure == null ? null : template.Structure.Clone() as Vector;
                StructureArray = template.StructureArray == null ? null : template.StructureArray.Clone() as Vector[];
                StructureWithAbstractBaseTypes = template.StructureWithAbstractBaseTypes == null ? null : template.StructureWithAbstractBaseTypes.Clone() as StructureWithAbstractBaseTypes;
                UInt16 = template.UInt16;
                UInt32 = template.UInt32;
                UInt64 = template.UInt64;
                XmlElement = template.XmlElement == null ? null : template.XmlElement.Clone() as XmlString;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Boolean
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public bool Boolean
        {
            get => m_Boolean;
            set => SetField(ref m_Boolean, value, nameof(Boolean));
        }
        private bool m_Boolean;

        /// <summary>
        /// Gets or sets the Byte
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public byte Byte
        {
            get => m_Byte;
            set => SetField(ref m_Byte, value, nameof(Byte));
        }
        private byte m_Byte;

        /// <summary>
        /// Gets or sets the ByteString
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public byte[] ByteString
        {
            get => m_ByteString;
            set => SetField(ref m_ByteString, value, nameof(ByteString));
        }
        private byte[] m_ByteString;

        /// <summary>
        /// Gets or sets the DateTime
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public DateTime DateTime
        {
            get => m_DateTime;
            set => SetField(ref m_DateTime, value, nameof(DateTime));
        }
        private DateTime m_DateTime;

        /// <summary>
        /// Gets or sets the Double
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public double Double
        {
            get => m_Double;
            set => SetField(ref m_Double, value, nameof(Double));
        }
        private double m_Double;

        /// <summary>
        /// Gets or sets the Enumeration
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public HeaterStatus Enumeration
        {
            get => m_Enumeration;
            set => SetField(ref m_Enumeration, value, nameof(Enumeration));
        }
        private HeaterStatus m_Enumeration;

        /// <summary>
        /// Gets or sets the ExpandedNodeId
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public ExpandedNodeId ExpandedNodeId
        {
            get => m_ExpandedNodeId;
            set => SetField(ref m_ExpandedNodeId, value, nameof(ExpandedNodeId));
        }
        private ExpandedNodeId m_ExpandedNodeId;

        /// <summary>
        /// Gets or sets the Float
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public float Float
        {
            get => m_Float;
            set => SetField(ref m_Float, value, nameof(Float));
        }
        private float m_Float;

        /// <summary>
        /// Gets or sets the Guid
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public Uuid Guid
        {
            get => m_Guid;
            set => SetField(ref m_Guid, value, nameof(Guid));
        }
        private Uuid m_Guid;

        /// <summary>
        /// Gets or sets the Int16
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public short Int16
        {
            get => m_Int16;
            set => SetField(ref m_Int16, value, nameof(Int16));
        }
        private short m_Int16;

        /// <summary>
        /// Gets or sets the Int32
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public int Int32
        {
            get => m_Int32;
            set => SetField(ref m_Int32, value, nameof(Int32));
        }
        private int m_Int32;

        /// <summary>
        /// Gets or sets the Int64
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public long Int64
        {
            get => m_Int64;
            set => SetField(ref m_Int64, value, nameof(Int64));
        }
        private long m_Int64;

        /// <summary>
        /// Gets or sets the LocalizedText
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public LocalizedText LocalizedText
        {
            get => m_LocalizedText;
            set => SetField(ref m_LocalizedText, value, nameof(LocalizedText));
        }
        private LocalizedText m_LocalizedText;

        /// <summary>
        /// Gets or sets the NodeIdNode
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model, BrowseName="NodeId")]
        public NodeId NodeIdNode
        {
            get => m_NodeIdNode;
            set => SetField(ref m_NodeIdNode, value, nameof(NodeIdNode));
        }
        private NodeId m_NodeIdNode;

        /// <summary>
        /// Gets or sets the OptionSetBase
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetBase OptionSetBase
        {
            get => m_OptionSetBase;
            set => SetField(ref m_OptionSetBase, value, nameof(OptionSetBase));
        }
        private OptionSetBase m_OptionSetBase;

        /// <summary>
        /// Gets or sets the OptionSetBaseArray
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetBase[] OptionSetBaseArray
        {
            get => m_OptionSetBaseArray;
            set => SetField(ref m_OptionSetBaseArray, value, nameof(OptionSetBaseArray));
        }
        private OptionSetBase[] m_OptionSetBaseArray;

        /// <summary>
        /// Gets or sets the OptionSetByte
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetByte OptionSetByte
        {
            get => m_OptionSetByte;
            set => SetField(ref m_OptionSetByte, value, nameof(OptionSetByte));
        }
        private OptionSetByte m_OptionSetByte;

        /// <summary>
        /// Gets or sets the OptionSetUInt16
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetUInt16 OptionSetUInt16
        {
            get => m_OptionSetUInt16;
            set => SetField(ref m_OptionSetUInt16, value, nameof(OptionSetUInt16));
        }
        private OptionSetUInt16 m_OptionSetUInt16;

        /// <summary>
        /// Gets or sets the OptionSetUInt16Array
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetUInt16[] OptionSetUInt16Array
        {
            get => m_OptionSetUInt16Array;
            set => SetField(ref m_OptionSetUInt16Array, value, nameof(OptionSetUInt16Array));
        }
        private OptionSetUInt16[] m_OptionSetUInt16Array;

        /// <summary>
        /// Gets or sets the OptionSetUInt32
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetUInt32 OptionSetUInt32
        {
            get => m_OptionSetUInt32;
            set => SetField(ref m_OptionSetUInt32, value, nameof(OptionSetUInt32));
        }
        private OptionSetUInt32 m_OptionSetUInt32;

        /// <summary>
        /// Gets or sets the OptionSetUInt64
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public OptionSetUInt64 OptionSetUInt64
        {
            get => m_OptionSetUInt64;
            set => SetField(ref m_OptionSetUInt64, value, nameof(OptionSetUInt64));
        }
        private OptionSetUInt64 m_OptionSetUInt64;

        /// <summary>
        /// Gets or sets the QualifiedName
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public QualifiedName QualifiedName
        {
            get => m_QualifiedName;
            set => SetField(ref m_QualifiedName, value, nameof(QualifiedName));
        }
        private QualifiedName m_QualifiedName;

        /// <summary>
        /// Gets or sets the SByte
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public sbyte SByte
        {
            get => m_SByte;
            set => SetField(ref m_SByte, value, nameof(SByte));
        }
        private sbyte m_SByte;

        /// <summary>
        /// Gets or sets the StatusCode
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public StatusCode StatusCode
        {
            get => m_StatusCode;
            set => SetField(ref m_StatusCode, value, nameof(StatusCode));
        }
        private StatusCode m_StatusCode;

        /// <summary>
        /// Gets or sets the String
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public string String
        {
            get => m_String;
            set => SetField(ref m_String, value, nameof(String));
        }
        private string m_String;

        /// <summary>
        /// Gets or sets the Structure
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public Vector Structure
        {
            get => m_Structure;
            set => SetField(ref m_Structure, value, nameof(Structure));
        }
        private Vector m_Structure;

        /// <summary>
        /// Gets or sets the StructureArray
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public Vector[] StructureArray
        {
            get => m_StructureArray;
            set => SetField(ref m_StructureArray, value, nameof(StructureArray));
        }
        private Vector[] m_StructureArray;

        /// <summary>
        /// Gets or sets the StructureWithAbstractBaseTypes
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public StructureWithAbstractBaseTypes StructureWithAbstractBaseTypes
        {
            get => m_StructureWithAbstractBaseTypes;
            set => SetField(ref m_StructureWithAbstractBaseTypes, value, nameof(StructureWithAbstractBaseTypes));
        }
        private StructureWithAbstractBaseTypes m_StructureWithAbstractBaseTypes;

        /// <summary>
        /// Gets or sets the UInt16
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public ushort UInt16
        {
            get => m_UInt16;
            set => SetField(ref m_UInt16, value, nameof(UInt16));
        }
        private ushort m_UInt16;

        /// <summary>
        /// Gets or sets the UInt32
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public uint UInt32
        {
            get => m_UInt32;
            set => SetField(ref m_UInt32, value, nameof(UInt32));
        }
        private uint m_UInt32;

        /// <summary>
        /// Gets or sets the UInt64
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public ulong UInt64
        {
            get => m_UInt64;
            set => SetField(ref m_UInt64, value, nameof(UInt64));
        }
        private ulong m_UInt64;

        /// <summary>
        /// Gets or sets the XmlElement
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public XmlString XmlElement
        {
            get => m_XmlElement;
            set => SetField(ref m_XmlElement, value, nameof(XmlElement));
        }
        private XmlString m_XmlElement;


        #endregion

        #region Event Handling Methods
        /// <summary>
        /// Updates the event.
        /// </summary>
        /// <param name="e">The event to update.</param>
        public override void UpdateEvent(GenericEvent e)
        {
            base.UpdateEvent(e);

            if (m_FieldHandles == null)
            {
                m_FieldHandles = new FieldHandle();
            }

            // Boolean
            if (m_FieldHandles.Boolean == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Boolean, e.Manager.NamespaceUris);
                m_FieldHandles.Boolean = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Boolean))
            {
                e.Set(m_FieldHandles.Boolean, this.Boolean);
            }

            // Byte
            if (m_FieldHandles.Byte == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Byte, e.Manager.NamespaceUris);
                m_FieldHandles.Byte = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Byte))
            {
                e.Set(m_FieldHandles.Byte, this.Byte);
            }

            // ByteString
            if (m_FieldHandles.ByteString == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.ByteString, e.Manager.NamespaceUris);
                m_FieldHandles.ByteString = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.ByteString))
            {
                e.Set(m_FieldHandles.ByteString, this.ByteString);
            }

            // DateTime
            if (m_FieldHandles.DateTime == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.DateTime, e.Manager.NamespaceUris);
                m_FieldHandles.DateTime = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.DateTime))
            {
                e.Set(m_FieldHandles.DateTime, this.DateTime);
            }

            // Double
            if (m_FieldHandles.Double == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Double, e.Manager.NamespaceUris);
                m_FieldHandles.Double = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Double))
            {
                e.Set(m_FieldHandles.Double, this.Double);
            }

            // Enumeration
            if (m_FieldHandles.Enumeration == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Enumeration, e.Manager.NamespaceUris);
                m_FieldHandles.Enumeration = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Enumeration))
            {
                e.Set(m_FieldHandles.Enumeration, (int) this.Enumeration);
            }

            // ExpandedNodeId
            if (m_FieldHandles.ExpandedNodeId == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.ExpandedNodeId, e.Manager.NamespaceUris);
                m_FieldHandles.ExpandedNodeId = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.ExpandedNodeId))
            {
                e.Set(m_FieldHandles.ExpandedNodeId, this.ExpandedNodeId);
            }

            // Float
            if (m_FieldHandles.Float == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Float, e.Manager.NamespaceUris);
                m_FieldHandles.Float = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Float))
            {
                e.Set(m_FieldHandles.Float, this.Float);
            }

            // Guid
            if (m_FieldHandles.Guid == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Guid, e.Manager.NamespaceUris);
                m_FieldHandles.Guid = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Guid))
            {
                e.Set(m_FieldHandles.Guid, this.Guid);
            }

            // Int16
            if (m_FieldHandles.Int16 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Int16, e.Manager.NamespaceUris);
                m_FieldHandles.Int16 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Int16))
            {
                e.Set(m_FieldHandles.Int16, this.Int16);
            }

            // Int32
            if (m_FieldHandles.Int32 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Int32, e.Manager.NamespaceUris);
                m_FieldHandles.Int32 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Int32))
            {
                e.Set(m_FieldHandles.Int32, this.Int32);
            }

            // Int64
            if (m_FieldHandles.Int64 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Int64, e.Manager.NamespaceUris);
                m_FieldHandles.Int64 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Int64))
            {
                e.Set(m_FieldHandles.Int64, this.Int64);
            }

            // LocalizedText
            if (m_FieldHandles.LocalizedText == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.LocalizedText, e.Manager.NamespaceUris);
                m_FieldHandles.LocalizedText = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.LocalizedText))
            {
                e.Set(m_FieldHandles.LocalizedText, this.LocalizedText);
            }

            // NodeIdNode
            if (m_FieldHandles.NodeIdNode == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.NodeId, e.Manager.NamespaceUris);
                m_FieldHandles.NodeIdNode = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.NodeIdNode))
            {
                e.Set(m_FieldHandles.NodeIdNode, this.NodeIdNode);
            }

            // OptionSetBase
            if (m_FieldHandles.OptionSetBase == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetBase, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetBase = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetBase))
            {
                e.Set(m_FieldHandles.OptionSetBase, this.OptionSetBase);
            }

            // OptionSetBaseArray
            if (m_FieldHandles.OptionSetBaseArray == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetBaseArray, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetBaseArray = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetBaseArray))
            {
                e.Set(m_FieldHandles.OptionSetBaseArray, new Variant(this.OptionSetBaseArray, null));
            }

            // OptionSetByte
            if (m_FieldHandles.OptionSetByte == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetByte, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetByte = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetByte))
            {
                e.Set(m_FieldHandles.OptionSetByte, (byte) this.OptionSetByte);
            }

            // OptionSetUInt16
            if (m_FieldHandles.OptionSetUInt16 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetUInt16, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetUInt16 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetUInt16))
            {
                e.Set(m_FieldHandles.OptionSetUInt16, (ushort) this.OptionSetUInt16);
            }

            // OptionSetUInt16Array
            if (m_FieldHandles.OptionSetUInt16Array == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetUInt16Array, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetUInt16Array = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetUInt16Array))
            {
                var collection = new UInt16Collection();
                foreach (var osv in this.OptionSetUInt16Array)
                {
                    collection.Add((ushort)osv);
                }

                e.Set(m_FieldHandles.OptionSetUInt16Array, new Variant(collection));
            }

            // OptionSetUInt32
            if (m_FieldHandles.OptionSetUInt32 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetUInt32, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetUInt32 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetUInt32))
            {
                e.Set(m_FieldHandles.OptionSetUInt32, (uint) this.OptionSetUInt32);
            }

            // OptionSetUInt64
            if (m_FieldHandles.OptionSetUInt64 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.OptionSetUInt64, e.Manager.NamespaceUris);
                m_FieldHandles.OptionSetUInt64 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.OptionSetUInt64))
            {
                e.Set(m_FieldHandles.OptionSetUInt64, (ulong) this.OptionSetUInt64);
            }

            // QualifiedName
            if (m_FieldHandles.QualifiedName == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.QualifiedName, e.Manager.NamespaceUris);
                m_FieldHandles.QualifiedName = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.QualifiedName))
            {
                e.Set(m_FieldHandles.QualifiedName, this.QualifiedName);
            }

            // SByte
            if (m_FieldHandles.SByte == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.SByte, e.Manager.NamespaceUris);
                m_FieldHandles.SByte = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.SByte))
            {
                e.Set(m_FieldHandles.SByte, this.SByte);
            }

            // StatusCode
            if (m_FieldHandles.StatusCode == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.StatusCode, e.Manager.NamespaceUris);
                m_FieldHandles.StatusCode = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.StatusCode))
            {
                e.Set(m_FieldHandles.StatusCode, this.StatusCode);
            }

            // String
            if (m_FieldHandles.String == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.String, e.Manager.NamespaceUris);
                m_FieldHandles.String = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.String))
            {
                e.Set(m_FieldHandles.String, this.String);
            }

            // Structure
            if (m_FieldHandles.Structure == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.Structure, e.Manager.NamespaceUris);
                m_FieldHandles.Structure = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.Structure))
            {
                e.Set(m_FieldHandles.Structure, new Variant(this.Structure));
            }

            // StructureArray
            if (m_FieldHandles.StructureArray == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.StructureArray, e.Manager.NamespaceUris);
                m_FieldHandles.StructureArray = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.StructureArray))
            {
                e.Set(m_FieldHandles.StructureArray, new Variant((IEnumerable<IEncodeable>)this.StructureArray));
            }

            // StructureWithAbstractBaseTypes
            if (m_FieldHandles.StructureWithAbstractBaseTypes == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.StructureWithAbstractBaseTypes, e.Manager.NamespaceUris);
                m_FieldHandles.StructureWithAbstractBaseTypes = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.StructureWithAbstractBaseTypes))
            {
                e.Set(m_FieldHandles.StructureWithAbstractBaseTypes, new Variant(this.StructureWithAbstractBaseTypes));
            }

            // UInt16
            if (m_FieldHandles.UInt16 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.UInt16, e.Manager.NamespaceUris);
                m_FieldHandles.UInt16 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.UInt16))
            {
                e.Set(m_FieldHandles.UInt16, this.UInt16);
            }

            // UInt32
            if (m_FieldHandles.UInt32 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.UInt32, e.Manager.NamespaceUris);
                m_FieldHandles.UInt32 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.UInt32))
            {
                e.Set(m_FieldHandles.UInt32, this.UInt32);
            }

            // UInt64
            if (m_FieldHandles.UInt64 == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.UInt64, e.Manager.NamespaceUris);
                m_FieldHandles.UInt64 = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.UInt64))
            {
                e.Set(m_FieldHandles.UInt64, this.UInt64);
            }

            // XmlElement
            if (m_FieldHandles.XmlElement == 0)
            {
                string name = AbsoluteName.ToString(AbsoluteNames.XmlElement, e.Manager.NamespaceUris);
                m_FieldHandles.XmlElement = e.Manager.CreateFieldHandle(name);
            }

            if (e.Manager.IsSubscribed(m_FieldHandles.XmlElement))
            {
                e.Set(m_FieldHandles.XmlElement, this.XmlElement);
            }
        }
        #region FieldHandle Class
        /// <summary>
        /// A class of handle values used by the class.
        /// </summary>
        private class FieldHandle
        {
            public int Boolean;
            public int Byte;
            public int ByteString;
            public int DateTime;
            public int Double;
            public int Enumeration;
            public int ExpandedNodeId;
            public int Float;
            public int Guid;
            public int Int16;
            public int Int32;
            public int Int64;
            public int LocalizedText;
            public int NodeIdNode;
            public int OptionSetBase;
            public int OptionSetBaseArray;
            public int OptionSetByte;
            public int OptionSetUInt16;
            public int OptionSetUInt16Array;
            public int OptionSetUInt32;
            public int OptionSetUInt64;
            public int QualifiedName;
            public int SByte;
            public int StatusCode;
            public int String;
            public int Structure;
            public int StructureArray;
            public int StructureWithAbstractBaseTypes;
            public int UInt16;
            public int UInt32;
            public int UInt64;
            public int XmlElement;
        }

        private FieldHandle m_FieldHandles;
        #endregion
        #endregion
    }
    #endregion


    #region WorkOrderVariableModel
    /// <summary>
    /// </summary>
    [UaTypeDefinition(NodeId=VariableTypes.WorkOrderVariableType, NamespaceUri=UnifiedAutomation.Demo.Model.Namespaces.Model)]
    public partial class WorkOrderVariableModel : BaseDataVariableModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="WorkOrderVariableModel" /> class.
        /// </summary>
        public WorkOrderVariableModel() : this((WorkOrderVariableModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WorkOrderVariableModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public WorkOrderVariableModel(WorkOrderVariableModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                AssetID = template.AssetID == null ? null : template.AssetID.Clone() as string;
                ID = template.ID;
                StartTime = template.StartTime;
                StatusComments = template.StatusComments == null ? null : template.StatusComments.Clone() as WorkOrderStatusType[];
            }
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// Gets or sets the value.
        /// </summary>
        [UaInstanceDeclaration(IsValue = true, NamespaceUri = UnifiedAutomation.Demo.Model.Namespaces.Model)]
        public new WorkOrderType Value
        {
            get {return (WorkOrderType) base.Value;}
            set {base.Value = value;}
        }

        /// <summary>
        /// Gets or sets the AssetID
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public string AssetID
        {
            get => m_AssetID;
            set => SetField(ref m_AssetID, value, nameof(AssetID));
        }
        private string m_AssetID;

        /// <summary>
        /// Gets or sets the ID
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public Uuid ID
        {
            get => m_ID;
            set => SetField(ref m_ID, value, nameof(ID));
        }
        private Uuid m_ID;

        /// <summary>
        /// Gets or sets the StartTime
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public DateTime StartTime
        {
            get => m_StartTime;
            set => SetField(ref m_StartTime, value, nameof(StartTime));
        }
        private DateTime m_StartTime;

        /// <summary>
        /// Gets or sets the StatusComments
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Model)]
        public WorkOrderStatusType[] StatusComments
        {
            get => m_StatusComments;
            set => SetField(ref m_StatusComments, value, nameof(StatusComments));
        }
        private WorkOrderStatusType[] m_StatusComments;


        #endregion
    }
    #endregion



}
