/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.7.0, using .NET Server 4.1.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2024 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://www.unifiedautomation.com/DemoServer/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Created: 16.08.2024
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using UnifiedAutomation.UaBase;
using System.Diagnostics;

namespace UnifiedAutomation.Demo.Model
{
    #region OptionSetByte flags
    /// <summary>
    /// The possible encodings for a OptionSetByte value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Obsolete("Use OptionSetByte instead")]
    [Flags]
    public enum OptionSetByteFlags : byte
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }

    /// <summary>
    /// The possible encodings for a OptionSetByte value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum OptionSetByte : byte
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }
    #endregion

    #region OptionSetByteBits bits
    /// <summary>
    /// The possible bits for a OptionSetByte value.
    /// </summary>
    public enum OptionSetByteBits
    {
        ERROR = 0,
        WARNING = 1,
        SYSTEM = 2,
        INFO = 3,
        DEBUG = 4,
        CONTENT = 5,
    }
    #endregion

    #region OptionSetUInt16 flags
    /// <summary>
    /// The possible encodings for a OptionSetUInt16 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Obsolete("Use OptionSetUInt16 instead")]
    [Flags]
    public enum OptionSetUInt16Flags : ushort
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }

    /// <summary>
    /// The possible encodings for a OptionSetUInt16 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum OptionSetUInt16 : ushort
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }
    #endregion

    #region OptionSetUInt16Bits bits
    /// <summary>
    /// The possible bits for a OptionSetUInt16 value.
    /// </summary>
    public enum OptionSetUInt16Bits
    {
        ERROR = 0,
        WARNING = 1,
        SYSTEM = 2,
        INFO = 3,
        DEBUG = 4,
        CONTENT = 5,
    }
    #endregion

    #region OptionSetUInt32 flags
    /// <summary>
    /// The possible encodings for a OptionSetUInt32 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Obsolete("Use OptionSetUInt32 instead")]
    [Flags]
    public enum OptionSetUInt32Flags : uint
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }

    /// <summary>
    /// The possible encodings for a OptionSetUInt32 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum OptionSetUInt32 : uint
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }
    #endregion

    #region OptionSetUInt32Bits bits
    /// <summary>
    /// The possible bits for a OptionSetUInt32 value.
    /// </summary>
    public enum OptionSetUInt32Bits
    {
        ERROR = 0,
        WARNING = 1,
        SYSTEM = 2,
        INFO = 3,
        DEBUG = 4,
        CONTENT = 5,
    }
    #endregion

    #region OptionSetUInt64 flags
    /// <summary>
    /// The possible encodings for a OptionSetUInt64 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Obsolete("Use OptionSetUInt64 instead")]
    [Flags]
    public enum OptionSetUInt64Flags : ulong
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "AA_1")]
        AA = 1,
        [EnumMember(Value = "BB_2")]
        BB = 2,
        [EnumMember(Value = "CC_4")]
        CC = 4,
        [EnumMember(Value = "DD_8")]
        DD = 8,
        [EnumMember(Value = "EE_16")]
        EE = 16,
        [EnumMember(Value = "FF_32")]
        FF = 32,
        [EnumMember(Value = "GG_64")]
        GG = 64,
        [EnumMember(Value = "HH_128")]
        HH = 128,
        [EnumMember(Value = "II_256")]
        II = 256,
        [EnumMember(Value = "JJ_512")]
        JJ = 512,
        [EnumMember(Value = "KK_1024")]
        KK = 1024,
        [EnumMember(Value = "LL_2048")]
        LL = 2048,
        [EnumMember(Value = "MM_4096")]
        MM = 4096,
        [EnumMember(Value = "NN_8192")]
        NN = 8192,
        [EnumMember(Value = "OO_16384")]
        OO = 16384,
        [EnumMember(Value = "PP_32768")]
        PP = 32768,
        [EnumMember(Value = "QQ_65536")]
        QQ = 65536,
        [EnumMember(Value = "RR_131072")]
        RR = 131072,
        [EnumMember(Value = "SS_262144")]
        SS = 262144,
        [EnumMember(Value = "TT_524288")]
        TT = 524288,
        [EnumMember(Value = "UU_1048576")]
        UU = 1048576,
        [EnumMember(Value = "VV_2097152")]
        VV = 2097152,
        [EnumMember(Value = "WW_4194304")]
        WW = 4194304,
        [EnumMember(Value = "XX_8388608")]
        XX = 8388608,
        [EnumMember(Value = "YY_16777216")]
        YY = 16777216,
        [EnumMember(Value = "ZZ_33554432")]
        ZZ = 33554432,
        [EnumMember(Value = "AAAA_67108864")]
        AAAA = 67108864,
        [EnumMember(Value = "BBBB_134217728")]
        BBBB = 134217728,
        [EnumMember(Value = "CCCC_268435456")]
        CCCC = 268435456,
        [EnumMember(Value = "DDDD_536870912")]
        DDDD = 536870912,
        [EnumMember(Value = "EEE_1073741824")]
        EEE = 1073741824,
        [EnumMember(Value = "FFFF_2147483648")]
        FFFF = 2147483648,
        [EnumMember(Value = "GGG_4294967296")]
        GGG = 4294967296,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 8589934591
    }

    /// <summary>
    /// The possible encodings for a OptionSetUInt64 value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum OptionSetUInt64 : ulong
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "AA_1")]
        AA = 1,
        [EnumMember(Value = "BB_2")]
        BB = 2,
        [EnumMember(Value = "CC_4")]
        CC = 4,
        [EnumMember(Value = "DD_8")]
        DD = 8,
        [EnumMember(Value = "EE_16")]
        EE = 16,
        [EnumMember(Value = "FF_32")]
        FF = 32,
        [EnumMember(Value = "GG_64")]
        GG = 64,
        [EnumMember(Value = "HH_128")]
        HH = 128,
        [EnumMember(Value = "II_256")]
        II = 256,
        [EnumMember(Value = "JJ_512")]
        JJ = 512,
        [EnumMember(Value = "KK_1024")]
        KK = 1024,
        [EnumMember(Value = "LL_2048")]
        LL = 2048,
        [EnumMember(Value = "MM_4096")]
        MM = 4096,
        [EnumMember(Value = "NN_8192")]
        NN = 8192,
        [EnumMember(Value = "OO_16384")]
        OO = 16384,
        [EnumMember(Value = "PP_32768")]
        PP = 32768,
        [EnumMember(Value = "QQ_65536")]
        QQ = 65536,
        [EnumMember(Value = "RR_131072")]
        RR = 131072,
        [EnumMember(Value = "SS_262144")]
        SS = 262144,
        [EnumMember(Value = "TT_524288")]
        TT = 524288,
        [EnumMember(Value = "UU_1048576")]
        UU = 1048576,
        [EnumMember(Value = "VV_2097152")]
        VV = 2097152,
        [EnumMember(Value = "WW_4194304")]
        WW = 4194304,
        [EnumMember(Value = "XX_8388608")]
        XX = 8388608,
        [EnumMember(Value = "YY_16777216")]
        YY = 16777216,
        [EnumMember(Value = "ZZ_33554432")]
        ZZ = 33554432,
        [EnumMember(Value = "AAAA_67108864")]
        AAAA = 67108864,
        [EnumMember(Value = "BBBB_134217728")]
        BBBB = 134217728,
        [EnumMember(Value = "CCCC_268435456")]
        CCCC = 268435456,
        [EnumMember(Value = "DDDD_536870912")]
        DDDD = 536870912,
        [EnumMember(Value = "EEE_1073741824")]
        EEE = 1073741824,
        [EnumMember(Value = "FFFF_2147483648")]
        FFFF = 2147483648,
        [EnumMember(Value = "GGG_4294967296")]
        GGG = 4294967296,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 8589934591
    }
    #endregion

    #region OptionSetUInt64Bits bits
    /// <summary>
    /// The possible bits for a OptionSetUInt64 value.
    /// </summary>
    public enum OptionSetUInt64Bits
    {
        AA = 0,
        BB = 1,
        CC = 2,
        DD = 3,
        EE = 4,
        FF = 5,
        GG = 6,
        HH = 7,
        II = 8,
        JJ = 9,
        KK = 10,
        LL = 11,
        MM = 12,
        NN = 13,
        OO = 14,
        PP = 15,
        QQ = 16,
        RR = 17,
        SS = 18,
        TT = 19,
        UU = 20,
        VV = 21,
        WW = 22,
        XX = 23,
        YY = 24,
        ZZ = 25,
        AAAA = 26,
        BBBB = 27,
        CCCC = 28,
        DDDD = 29,
        EEE = 30,
        FFFF = 31,
        GGG = 32,
    }
    #endregion

    #region AccessRights flags
    /// <summary>
    /// The possible encodings for a AccessRights value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum AccessRightsFlags : byte
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "Read_1")]
        Read = 1,
        [EnumMember(Value = "Write_2")]
        Write = 2,
        [EnumMember(Value = "Execute_4")]
        Execute = 4,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 7
    }
    #endregion

    #region AccessRightsBits bits
    /// <summary>
    /// The possible bits for a AccessRights value.
    /// </summary>
    public enum AccessRightsBits
    {
        Read = 0,
        Write = 1,
        Execute = 2,
    }
    #endregion

    #region OptionSetBase flags
    /// <summary>
    /// The possible encodings for a OptionSetBase value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    [Flags]
    public enum OptionSetBaseFlags : byte
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        [EnumMember(Value = "ERROR_1")]
        ERROR = 1,
        [EnumMember(Value = "WARNING_2")]
        WARNING = 2,
        [EnumMember(Value = "SYSTEM_4")]
        SYSTEM = 4,
        [EnumMember(Value = "INFO_8")]
        INFO = 8,
        [EnumMember(Value = "DEBUG_16")]
        DEBUG = 16,
        [EnumMember(Value = "CONTENT_32")]
        CONTENT = 32,
        /// <summary>
        /// All bits are set
        /// </summary>
        All = 63
    }
    #endregion

    #region OptionSetBaseBits bits
    /// <summary>
    /// The possible bits for a OptionSetBase value.
    /// </summary>
    public enum OptionSetBaseBits
    {
        ERROR = 0,
        WARNING = 1,
        SYSTEM = 2,
        INFO = 3,
        DEBUG = 4,
        CONTENT = 5,
    }
    #endregion

    #region HeaterStatus
    /// <summary>
    /// The possible encodings for a HeaterStatus value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public enum HeaterStatus
    {
        [EnumMember(Value = "Off_0")]
        Off = 0,
        [EnumMember(Value = "Heating_1")]
        Heating = 1,
        [EnumMember(Value = "Cooling_2")]
        Cooling = 2,
    }

    #region HeaterStatusCollection Class
    /// <summary>
    /// A collection of HeaterStatus objects.
    /// </summary>
    [CollectionDataContract]
    public partial class HeaterStatusCollection : List<HeaterStatus>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public HeaterStatusCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public HeaterStatusCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public HeaterStatusCollection(IEnumerable<HeaterStatus> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator HeaterStatusCollection(HeaterStatus[] values)
        {
            if (values != null)
            {
                return new HeaterStatusCollection(values);
            }

            return new HeaterStatusCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator HeaterStatus[](HeaterStatusCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            HeaterStatusCollection clone = new HeaterStatusCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((HeaterStatus)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region Priority
    /// <summary>
    /// This enumerated value defines its possible values in an EnumValues property
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public enum Priority
    {
        [EnumMember(Value = "Low_10")]
        Low = 10,
        [EnumMember(Value = "Normal_40")]
        Normal = 40,
        [EnumMember(Value = "High_70")]
        High = 70,
        [EnumMember(Value = "Urgent_90")]
        Urgent = 90,
        [EnumMember(Value = "Immediate_100")]
        Immediate = 100,
    }

    #region PriorityCollection Class
    /// <summary>
    /// A collection of Priority objects.
    /// </summary>
    [CollectionDataContract]
    public partial class PriorityCollection : List<Priority>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public PriorityCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public PriorityCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public PriorityCollection(IEnumerable<Priority> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator PriorityCollection(Priority[] values)
        {
            if (values != null)
            {
                return new PriorityCollection(values);
            }

            return new PriorityCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator Priority[](PriorityCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            PriorityCollection clone = new PriorityCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((Priority)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region AbstractBaseType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class AbstractBaseType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public AbstractBaseType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Double = 0.0;
            m_Int16 = (short)0;
            m_UInt32 = (uint)0;
            m_String = null;
            m_QualifiedName = null;
            m_LocalizedText = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Double", IsRequired = false, Order = 1)]
        public double Double
        {
            get
            {
                return m_Double;
            }
            set
            {
                m_Double = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Int16", IsRequired = false, Order = 2)]
        public short Int16
        {
            get
            {
                return m_Int16;
            }
            set
            {
                m_Int16 = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "UInt32", IsRequired = false, Order = 3)]
        public uint UInt32
        {
            get
            {
                return m_UInt32;
            }
            set
            {
                m_UInt32 = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "String", IsRequired = false, Order = 4)]
        public string String
        {
            get
            {
                return m_String;
            }
            set
            {
                m_String = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "QualifiedName", IsRequired = false, Order = 5)]
        public QualifiedName QualifiedName
        {
            get
            {
                return m_QualifiedName;
            }
            set
            {
                m_QualifiedName = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "LocalizedText", IsRequired = false, Order = 6)]
        public LocalizedText LocalizedText
        {
            get
            {
                return m_LocalizedText;
            }
            set
            {
                m_LocalizedText = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.AbstractBaseType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId { get { return NodeId.Null; } }

        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId { get { return NodeId.Null; } }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteDouble("Double", Double);
            encoder.WriteInt16("Int16", Int16);
            encoder.WriteUInt32("UInt32", UInt32);
            encoder.WriteString("String", String);
            encoder.WriteQualifiedName("QualifiedName", QualifiedName);
            encoder.WriteLocalizedText("LocalizedText", LocalizedText);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            Double = decoder.ReadDouble("Double");
            Int16 = decoder.ReadInt16("Int16");
            UInt32 = decoder.ReadUInt32("UInt32");
            String = decoder.ReadString("String");
            QualifiedName = decoder.ReadQualifiedName("QualifiedName");
            LocalizedText = decoder.ReadLocalizedText("LocalizedText");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            AbstractBaseType value = encodeable as AbstractBaseType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_Double, value.m_Double)) return false;
            if (!TypeUtils.IsEqual(m_Int16, value.m_Int16)) return false;
            if (!TypeUtils.IsEqual(m_UInt32, value.m_UInt32)) return false;
            if (!TypeUtils.IsEqual(m_String, value.m_String)) return false;
            if (!TypeUtils.IsEqual(m_QualifiedName, value.m_QualifiedName)) return false;
            if (!TypeUtils.IsEqual(m_LocalizedText, value.m_LocalizedText)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            AbstractBaseType clone = (AbstractBaseType)this.MemberwiseClone();

            clone.m_Double = (double)TypeUtils.Clone(this.m_Double);
            clone.m_Int16 = (short)TypeUtils.Clone(this.m_Int16);
            clone.m_UInt32 = (uint)TypeUtils.Clone(this.m_UInt32);
            clone.m_String = (string)TypeUtils.Clone(this.m_String);
            clone.m_QualifiedName = (QualifiedName)TypeUtils.Clone(this.m_QualifiedName);
            clone.m_LocalizedText = (LocalizedText)TypeUtils.Clone(this.m_LocalizedText);

            return clone;
        }
        #endregion

        #region Private Fields
        private double m_Double;
        private short m_Int16;
        private uint m_UInt32;
        private string m_String;
        private QualifiedName m_QualifiedName;
        private LocalizedText m_LocalizedText;
        #endregion
    }

    #region AbstractBaseTypeCollection class
    /// <summary>
    /// A collection of AbstractBaseType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfAbstractBaseType", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "AbstractBaseType")]
    public partial class AbstractBaseTypeCollection : List<AbstractBaseType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public AbstractBaseTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public AbstractBaseTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public AbstractBaseTypeCollection(IEnumerable<AbstractBaseType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator AbstractBaseTypeCollection(AbstractBaseType[] values)
        {
            if (values != null)
            {
                return new AbstractBaseTypeCollection(values);
            }

            return new AbstractBaseTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator AbstractBaseType[](AbstractBaseTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            AbstractBaseTypeCollection clone = new AbstractBaseTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((AbstractBaseType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region ConcreteSubType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class ConcreteSubType : AbstractBaseType
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public ConcreteSubType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
        }
        #endregion

        #region Public Properties

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.ConcreteSubType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.ConcreteSubType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.ConcreteSubType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);


            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            ConcreteSubType value = encodeable as ConcreteSubType;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;


            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            ConcreteSubType clone = (ConcreteSubType)base.Clone();


            return clone;
        }
        #endregion

        #region Private Fields
        #endregion
    }

    #region ConcreteSubTypeCollection class
    /// <summary>
    /// A collection of ConcreteSubType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfConcreteSubType", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "ConcreteSubType")]
    public partial class ConcreteSubTypeCollection : List<ConcreteSubType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public ConcreteSubTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public ConcreteSubTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public ConcreteSubTypeCollection(IEnumerable<ConcreteSubType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator ConcreteSubTypeCollection(ConcreteSubType[] values)
        {
            if (values != null)
            {
                return new ConcreteSubTypeCollection(values);
            }

            return new ConcreteSubTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator ConcreteSubType[](ConcreteSubTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            ConcreteSubTypeCollection clone = new ConcreteSubTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((ConcreteSubType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region ExtendedSubType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class ExtendedSubType : ConcreteSubType
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public ExtendedSubType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_OptionSet = OptionSetUInt64.None;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "OptionSet", IsRequired = false, Order = 1)]
        public OptionSetUInt64 OptionSet
        {
            get
            {
                return m_OptionSet;
            }
            set
            {
                m_OptionSet = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.ExtendedSubType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.ExtendedSubType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.ExtendedSubType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteUInt64("OptionSet", (ulong) OptionSet);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            OptionSet = (OptionSetUInt64) decoder.ReadUInt64("OptionSet");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            ExtendedSubType value = encodeable as ExtendedSubType;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;

            if (!TypeUtils.IsEqual(m_OptionSet, value.m_OptionSet)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            ExtendedSubType clone = (ExtendedSubType)base.Clone();

            clone.m_OptionSet = (OptionSetUInt64)TypeUtils.Clone(this.m_OptionSet);

            return clone;
        }
        #endregion

        #region Private Fields
        private OptionSetUInt64 m_OptionSet;
        #endregion
    }

    #region ExtendedSubTypeCollection class
    /// <summary>
    /// A collection of ExtendedSubType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfExtendedSubType", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "ExtendedSubType")]
    public partial class ExtendedSubTypeCollection : List<ExtendedSubType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public ExtendedSubTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public ExtendedSubTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public ExtendedSubTypeCollection(IEnumerable<ExtendedSubType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator ExtendedSubTypeCollection(ExtendedSubType[] values)
        {
            if (values != null)
            {
                return new ExtendedSubTypeCollection(values);
            }

            return new ExtendedSubTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator ExtendedSubType[](ExtendedSubTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            ExtendedSubTypeCollection clone = new ExtendedSubTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((ExtendedSubType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region AccessRights Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class AccessRights : UnifiedAutomation.UaBase.OptionSet
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public AccessRights()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            Value = new byte[ 1 ];
            ValidBits = new byte[ 1 ];
            ValidBits[ 0 ] = 7;

        }
        #endregion

        #region Public Properties

        #endregion

        #region OptionSet convenience methods
        /// <summary>
        /// </summary>
        public AccessRightsFlags Flags
        {
            get
            {
                byte tmp = Value[0];
                return (AccessRightsFlags)tmp;
            }
            set
            {
                Value[0] = (byte) value;
            }
        }

        /// <summary>
        /// </summary>
        public AccessRightsFlags ValidFlags
        {
            get
            {
                byte tmp = ValidBits[0];
                return (AccessRightsFlags)tmp;
            }
            set
            {
                ValidBits[0] = (byte) value;
            }
        }

        /// <summary>
        /// </summary>
        virtual public void Apply(AccessRights other)
        {
            base.Apply(other);
        }

        /// <summary>
        /// </summary>
        public void SetValidBits(AccessRightsFlags flags)
        {
            ValidBits[0] = (byte) flags;
        }

        /// <summary>
        /// </summary>
        public void SetInvalidBits(AccessRightsFlags flags)
        {
            AccessRightsFlags valid = ~flags;
            SetValidBits(valid);
        }

        /// <summary>
        /// </summary>
        public bool IsValid()
        {
            return Value.Length == 1
                && ValidBits.Length == 1
                && ((Flags & ~AccessRightsFlags.All) == 0)
                && ((ValidFlags & ~AccessRightsFlags.All) == 0);
        }
        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.AccessRights; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.AccessRights_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.AccessRights_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);


            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            AccessRights value = encodeable as AccessRights;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;


            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            AccessRights clone = (AccessRights)base.Clone();


            return clone;
        }
        #endregion

        #region Private Fields
        #endregion
    }

    #region AccessRightsCollection class
    /// <summary>
    /// A collection of AccessRights objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfAccessRights", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "AccessRights")]
    public partial class AccessRightsCollection : List<AccessRights>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public AccessRightsCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public AccessRightsCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public AccessRightsCollection(IEnumerable<AccessRights> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator AccessRightsCollection(AccessRights[] values)
        {
            if (values != null)
            {
                return new AccessRightsCollection(values);
            }

            return new AccessRightsCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator AccessRights[](AccessRightsCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            AccessRightsCollection clone = new AccessRightsCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((AccessRights)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region OptionSetBase Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class OptionSetBase : UnifiedAutomation.UaBase.OptionSet
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public OptionSetBase()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            Value = new byte[ 1 ];
            ValidBits = new byte[ 1 ];
            ValidBits[ 0 ] = 63;

        }
        #endregion

        #region Public Properties

        #endregion

        #region OptionSet convenience methods
        /// <summary>
        /// </summary>
        public OptionSetBaseFlags Flags
        {
            get
            {
                byte tmp = Value[0];
                return (OptionSetBaseFlags)tmp;
            }
            set
            {
                Value[0] = (byte) value;
            }
        }

        /// <summary>
        /// </summary>
        public OptionSetBaseFlags ValidFlags
        {
            get
            {
                byte tmp = ValidBits[0];
                return (OptionSetBaseFlags)tmp;
            }
            set
            {
                ValidBits[0] = (byte) value;
            }
        }

        /// <summary>
        /// </summary>
        virtual public void Apply(OptionSetBase other)
        {
            base.Apply(other);
        }

        /// <summary>
        /// </summary>
        public void SetValidBits(OptionSetBaseFlags flags)
        {
            ValidBits[0] = (byte) flags;
        }

        /// <summary>
        /// </summary>
        public void SetInvalidBits(OptionSetBaseFlags flags)
        {
            OptionSetBaseFlags valid = ~flags;
            SetValidBits(valid);
        }

        /// <summary>
        /// </summary>
        public bool IsValid()
        {
            return Value.Length == 1
                && ValidBits.Length == 1
                && ((Flags & ~OptionSetBaseFlags.All) == 0)
                && ((ValidFlags & ~OptionSetBaseFlags.All) == 0);
        }
        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.OptionSetBase; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.OptionSetBase_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.OptionSetBase_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);


            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            OptionSetBase value = encodeable as OptionSetBase;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;


            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            OptionSetBase clone = (OptionSetBase)base.Clone();


            return clone;
        }
        #endregion

        #region Private Fields
        #endregion
    }

    #region OptionSetBaseCollection class
    /// <summary>
    /// A collection of OptionSetBase objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfOptionSetBase", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "OptionSetBase")]
    public partial class OptionSetBaseCollection : List<OptionSetBase>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public OptionSetBaseCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public OptionSetBaseCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public OptionSetBaseCollection(IEnumerable<OptionSetBase> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator OptionSetBaseCollection(OptionSetBase[] values)
        {
            if (values != null)
            {
                return new OptionSetBaseCollection(values);
            }

            return new OptionSetBaseCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator OptionSetBase[](OptionSetBaseCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            OptionSetBaseCollection clone = new OptionSetBaseCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((OptionSetBase)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region StructureWithAbstractBaseTypes Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class StructureWithAbstractBaseTypes : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public StructureWithAbstractBaseTypes()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Base1 = null;
            m_Base2 = null;
            m_Number = Variant.Null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Base1", IsRequired = false, Order = 1)]
        public ExtensionObject Base1_ExtensionObject
        {
            get
            {
                return m_Base1;
            }
            private set
            {
                m_Base1 = value;
            }
        }

        public AbstractBaseType Base1
        {
            get
            {
                return ExtensionObject.GetObject<AbstractBaseType>(m_Base1);
            }
            set
            {
                m_Base1 = new ExtensionObject(value);
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Base2", IsRequired = false, Order = 2)]
        public ExtensionObject Base2_ExtensionObject
        {
            get
            {
                return m_Base2;
            }
            private set
            {
                m_Base2 = value;
            }
        }

        public AbstractBaseType Base2
        {
            get
            {
                return ExtensionObject.GetObject<AbstractBaseType>(m_Base2);
            }
            set
            {
                m_Base2 = new ExtensionObject(value);
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Number", IsRequired = false, Order = 3)]
        public Variant Number
        {
            get
            {
                return m_Number;
            }
            set
            {
                m_Number = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.StructureWithAbstractBaseTypes; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithAbstractBaseTypes_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithAbstractBaseTypes_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteExtensionObject("Base1", m_Base1);
            encoder.WriteExtensionObject("Base2", m_Base2);
            encoder.WriteVariant("Number", Number);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            m_Base1 = decoder.ReadExtensionObject("Base1");
            m_Base2 = decoder.ReadExtensionObject("Base2");
            Number = decoder.ReadVariant("Number");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            StructureWithAbstractBaseTypes value = encodeable as StructureWithAbstractBaseTypes;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_Base1, value.m_Base1)) return false;
            if (!TypeUtils.IsEqual(m_Base2, value.m_Base2)) return false;
            if (!TypeUtils.IsEqual(m_Number, value.m_Number)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            StructureWithAbstractBaseTypes clone = (StructureWithAbstractBaseTypes)this.MemberwiseClone();

            clone.m_Base1 = (ExtensionObject)TypeUtils.Clone(this.m_Base1);
            clone.m_Base2 = (ExtensionObject)TypeUtils.Clone(this.m_Base2);
            clone.m_Number = (Variant)TypeUtils.Clone(this.m_Number);

            return clone;
        }
        #endregion

        #region Private Fields
        private ExtensionObject m_Base1;
        private ExtensionObject m_Base2;
        private Variant m_Number;
        #endregion
    }

    #region StructureWithAbstractBaseTypesCollection class
    /// <summary>
    /// A collection of StructureWithAbstractBaseTypes objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfStructureWithAbstractBaseTypes", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "StructureWithAbstractBaseTypes")]
    public partial class StructureWithAbstractBaseTypesCollection : List<StructureWithAbstractBaseTypes>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public StructureWithAbstractBaseTypesCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public StructureWithAbstractBaseTypesCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public StructureWithAbstractBaseTypesCollection(IEnumerable<StructureWithAbstractBaseTypes> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator StructureWithAbstractBaseTypesCollection(StructureWithAbstractBaseTypes[] values)
        {
            if (values != null)
            {
                return new StructureWithAbstractBaseTypesCollection(values);
            }

            return new StructureWithAbstractBaseTypesCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator StructureWithAbstractBaseTypes[](StructureWithAbstractBaseTypesCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            StructureWithAbstractBaseTypesCollection clone = new StructureWithAbstractBaseTypesCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((StructureWithAbstractBaseTypes)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region StructureWithAllowSubtypes Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class StructureWithAllowSubtypes : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public StructureWithAllowSubtypes()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Base1 = null;
            m_Base2 = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Base1", IsRequired = false, Order = 1)]
        public ExtensionObject Base1_ExtensionObject
        {
            get
            {
                return m_Base1;
            }
            private set
            {
                m_Base1 = value;
            }
        }

        public AbstractBaseType Base1
        {
            get
            {
                return ExtensionObject.GetObject<AbstractBaseType>(m_Base1);
            }
            set
            {
                m_Base1 = new ExtensionObject(value);
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Base2", IsRequired = false, Order = 2)]
        public ExtensionObject Base2_ExtensionObject
        {
            get
            {
                return m_Base2;
            }
            private set
            {
                m_Base2 = value;
            }
        }

        public ConcreteSubType Base2
        {
            get
            {
                return ExtensionObject.GetObject<ConcreteSubType>(m_Base2);
            }
            set
            {
                m_Base2 = new ExtensionObject(value);
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.StructureWithAllowSubtypes; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithAllowSubtypes_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithAllowSubtypes_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteExtensionObject("Base1", m_Base1);
            encoder.WriteExtensionObject("Base2", m_Base2);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            m_Base1 = decoder.ReadExtensionObject("Base1");
            m_Base2 = decoder.ReadExtensionObject("Base2");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            StructureWithAllowSubtypes value = encodeable as StructureWithAllowSubtypes;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_Base1, value.m_Base1)) return false;
            if (!TypeUtils.IsEqual(m_Base2, value.m_Base2)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            StructureWithAllowSubtypes clone = (StructureWithAllowSubtypes)this.MemberwiseClone();

            clone.m_Base1 = (ExtensionObject)TypeUtils.Clone(this.m_Base1);
            clone.m_Base2 = (ExtensionObject)TypeUtils.Clone(this.m_Base2);

            return clone;
        }
        #endregion

        #region Private Fields
        private ExtensionObject m_Base1;
        private ExtensionObject m_Base2;
        #endregion
    }

    #region StructureWithAllowSubtypesCollection class
    /// <summary>
    /// A collection of StructureWithAllowSubtypes objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfStructureWithAllowSubtypes", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "StructureWithAllowSubtypes")]
    public partial class StructureWithAllowSubtypesCollection : List<StructureWithAllowSubtypes>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public StructureWithAllowSubtypesCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public StructureWithAllowSubtypesCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public StructureWithAllowSubtypesCollection(IEnumerable<StructureWithAllowSubtypes> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator StructureWithAllowSubtypesCollection(StructureWithAllowSubtypes[] values)
        {
            if (values != null)
            {
                return new StructureWithAllowSubtypesCollection(values);
            }

            return new StructureWithAllowSubtypesCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator StructureWithAllowSubtypes[](StructureWithAllowSubtypesCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            StructureWithAllowSubtypesCollection clone = new StructureWithAllowSubtypesCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((StructureWithAllowSubtypes)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region StructureWithDerivedStructures Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class StructureWithDerivedStructures : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public StructureWithDerivedStructures()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_BuildInfo = null;
            m_Vector = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "BuildInfo", IsRequired = false, Order = 1)]
        public BuildInfo BuildInfo
        {
            get
            {
                return m_BuildInfo;
            }
            set
            {
                m_BuildInfo = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Vector", IsRequired = false, Order = 2)]
        public Vector Vector
        {
            get
            {
                return m_Vector;
            }
            set
            {
                m_Vector = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.StructureWithDerivedStructures; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithDerivedStructures_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithDerivedStructures_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteEncodeable("BuildInfo", BuildInfo, typeof(BuildInfo));
            encoder.WriteEncodeable("Vector", Vector, typeof(Vector));

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            BuildInfo = (BuildInfo) decoder.ReadEncodeable("BuildInfo", typeof(BuildInfo));
            Vector = (Vector) decoder.ReadEncodeable("Vector", typeof(Vector));

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            StructureWithDerivedStructures value = encodeable as StructureWithDerivedStructures;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_BuildInfo, value.m_BuildInfo)) return false;
            if (!TypeUtils.IsEqual(m_Vector, value.m_Vector)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            StructureWithDerivedStructures clone = (StructureWithDerivedStructures)this.MemberwiseClone();

            clone.m_BuildInfo = (BuildInfo)TypeUtils.Clone(this.m_BuildInfo);
            clone.m_Vector = (Vector)TypeUtils.Clone(this.m_Vector);

            return clone;
        }
        #endregion

        #region Private Fields
        private BuildInfo m_BuildInfo;
        private Vector m_Vector;
        #endregion
    }

    #region StructureWithDerivedStructuresCollection class
    /// <summary>
    /// A collection of StructureWithDerivedStructures objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfStructureWithDerivedStructures", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "StructureWithDerivedStructures")]
    public partial class StructureWithDerivedStructuresCollection : List<StructureWithDerivedStructures>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public StructureWithDerivedStructuresCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public StructureWithDerivedStructuresCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public StructureWithDerivedStructuresCollection(IEnumerable<StructureWithDerivedStructures> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator StructureWithDerivedStructuresCollection(StructureWithDerivedStructures[] values)
        {
            if (values != null)
            {
                return new StructureWithDerivedStructuresCollection(values);
            }

            return new StructureWithDerivedStructuresCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator StructureWithDerivedStructures[](StructureWithDerivedStructuresCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            StructureWithDerivedStructuresCollection clone = new StructureWithDerivedStructuresCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((StructureWithDerivedStructures)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region StructureWithDifferentDataTypes Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class StructureWithDifferentDataTypes : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public StructureWithDifferentDataTypes()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_OptionSetType = null;
            m_EnumerationType = HeaterStatus.Off;
            m_StructureType = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "OptionSetType", IsRequired = false, Order = 1)]
        public OptionSetBase OptionSetType
        {
            get
            {
                return m_OptionSetType;
            }
            set
            {
                m_OptionSetType = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "EnumerationType", IsRequired = false, Order = 2)]
        public HeaterStatus EnumerationType
        {
            get
            {
                return m_EnumerationType;
            }
            set
            {
                m_EnumerationType = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "StructureType", IsRequired = false, Order = 3)]
        public Vector StructureType
        {
            get
            {
                return m_StructureType;
            }
            set
            {
                m_StructureType = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.StructureWithDifferentDataTypes; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithDifferentDataTypes_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithDifferentDataTypes_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteEncodeable("OptionSetType", OptionSetType, typeof(OptionSetBase));
            encoder.WriteEnumerated("EnumerationType", EnumerationType);
            encoder.WriteEncodeable("StructureType", StructureType, typeof(Vector));

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            OptionSetType = (OptionSetBase) decoder.ReadEncodeable("OptionSetType", typeof(OptionSetBase));
            EnumerationType = (HeaterStatus) decoder.ReadEnumerated("EnumerationType", typeof(HeaterStatus));
            StructureType = (Vector) decoder.ReadEncodeable("StructureType", typeof(Vector));

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            StructureWithDifferentDataTypes value = encodeable as StructureWithDifferentDataTypes;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_OptionSetType, value.m_OptionSetType)) return false;
            if (!TypeUtils.IsEqual(m_EnumerationType, value.m_EnumerationType)) return false;
            if (!TypeUtils.IsEqual(m_StructureType, value.m_StructureType)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            StructureWithDifferentDataTypes clone = (StructureWithDifferentDataTypes)this.MemberwiseClone();

            clone.m_OptionSetType = (OptionSetBase)TypeUtils.Clone(this.m_OptionSetType);
            clone.m_EnumerationType = (HeaterStatus)TypeUtils.Clone(this.m_EnumerationType);
            clone.m_StructureType = (Vector)TypeUtils.Clone(this.m_StructureType);

            return clone;
        }
        #endregion

        #region Private Fields
        private OptionSetBase m_OptionSetType;
        private HeaterStatus m_EnumerationType;
        private Vector m_StructureType;
        #endregion
    }

    #region StructureWithDifferentDataTypesCollection class
    /// <summary>
    /// A collection of StructureWithDifferentDataTypes objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfStructureWithDifferentDataTypes", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "StructureWithDifferentDataTypes")]
    public partial class StructureWithDifferentDataTypesCollection : List<StructureWithDifferentDataTypes>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public StructureWithDifferentDataTypesCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public StructureWithDifferentDataTypesCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public StructureWithDifferentDataTypesCollection(IEnumerable<StructureWithDifferentDataTypes> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator StructureWithDifferentDataTypesCollection(StructureWithDifferentDataTypes[] values)
        {
            if (values != null)
            {
                return new StructureWithDifferentDataTypesCollection(values);
            }

            return new StructureWithDifferentDataTypesCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator StructureWithDifferentDataTypes[](StructureWithDifferentDataTypesCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            StructureWithDifferentDataTypesCollection clone = new StructureWithDifferentDataTypesCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((StructureWithDifferentDataTypes)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region StructureWithOptionalFields Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class StructureWithOptionalFields : IEncodeable
    {
        #region Optional Members
        [Flags]
        private enum StructureWithOptionalFieldsSet
        {
            OptionalInt32 = 1,
            OptionalStringArray = 2,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public StructureWithOptionalFields()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_encodingMask = 0;
            m_MandatoryInt32 = (int)0;
            m_OptionalInt32 = null;
            m_MandatoryStringArray = new StringCollection();
            m_OptionalStringArray = null;
        }
        #endregion

        #region Public Properties
        [DataMember(Name = "EncodingMask", IsRequired = false, Order = 1)]
        private uint EncodingMask
        {
            get
            {
                return m_encodingMask;
            }
            set
            {
                m_encodingMask = value;
            }
        }


        /// <summary>
        /// </summary>
        [DataMember(Name = "MandatoryInt32", IsRequired = false, Order = 2)]
        public int MandatoryInt32
        {
            get
            {
                return m_MandatoryInt32;
            }
            set
            {
                m_MandatoryInt32 = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "OptionalInt32", IsRequired = false, Order = 3)]
        public int? OptionalInt32
        {
            get
            {
                return m_OptionalInt32;
            }
            set
            {
                m_OptionalInt32 = value;
                m_encodingMask |= (uint) StructureWithOptionalFieldsSet.OptionalInt32;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "MandatoryStringArray", IsRequired = false, Order = 4)]
        public StringCollection MandatoryStringArray
        {
            get
            {
                return m_MandatoryStringArray;
            }
            set
            {
                m_MandatoryStringArray = value;

                if (value == null)
                {
                    m_MandatoryStringArray = new StringCollection();
                }
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "OptionalStringArray", IsRequired = false, Order = 5)]
        public StringCollection OptionalStringArray
        {
            get
            {
                return m_OptionalStringArray;
            }
            set
            {
                m_OptionalStringArray = value;

                if (value == null)
                {
                    m_OptionalStringArray = new StringCollection();
                }
                m_encodingMask |= (uint) StructureWithOptionalFieldsSet.OptionalStringArray;
            }
        }


        /// <summary>
        /// Checks if the field is present.
        /// </summary>
        public bool IsOptionalInt32Set()
        {
            return (m_encodingMask & (uint) StructureWithOptionalFieldsSet.OptionalInt32) != 0;
        }

        /// <summary>
        /// Unsets the bit in the encoding mask and clears the field.
        /// </summary>
        public void UnsetOptionalInt32()
        {
            m_encodingMask &= (~((uint)StructureWithOptionalFieldsSet.OptionalInt32));
            m_OptionalInt32 = null;
        }

        /// <summary>
        /// Checks if the field is present.
        /// </summary>
        public bool IsOptionalStringArraySet()
        {
            return (m_encodingMask & (uint) StructureWithOptionalFieldsSet.OptionalStringArray) != 0;
        }

        /// <summary>
        /// Unsets the bit in the encoding mask and clears the field.
        /// </summary>
        public void UnsetOptionalStringArray()
        {
            m_encodingMask &= (~((uint)StructureWithOptionalFieldsSet.OptionalStringArray));
            m_OptionalStringArray = null;
        }
        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.StructureWithOptionalFields; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithOptionalFields_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.StructureWithOptionalFields_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteEncodingMask(m_encodingMask);

            encoder.WriteInt32("MandatoryInt32", MandatoryInt32);
            if (IsOptionalInt32Set())
            {
                encoder.WriteInt32("OptionalInt32", OptionalInt32.Value);
            }
            encoder.WriteStringArray("MandatoryStringArray", MandatoryStringArray);
            if (IsOptionalStringArraySet())
            {
                encoder.WriteStringArray("OptionalStringArray", OptionalStringArray);
            }

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            m_encodingMask = decoder.ReadUInt32("EncodingMask");

            MandatoryInt32 = decoder.ReadInt32("MandatoryInt32");
            if (IsOptionalInt32Set())
            {
                OptionalInt32 = decoder.ReadInt32("OptionalInt32");
            }
            MandatoryStringArray = decoder.ReadStringArray("MandatoryStringArray");
            if (IsOptionalStringArraySet())
            {
                OptionalStringArray = decoder.ReadStringArray("OptionalStringArray");
            }

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            StructureWithOptionalFields value = encodeable as StructureWithOptionalFields;

            if (value == null)
            {
                return false;
            }
            if (m_encodingMask != value.m_encodingMask) return false;
            if (!TypeUtils.IsEqual(m_MandatoryInt32, value.m_MandatoryInt32)) return false;
            if (IsOptionalInt32Set())
            {
                if (!TypeUtils.IsEqual(m_OptionalInt32, value.m_OptionalInt32)) return false;
            }
            if (!TypeUtils.IsEqual(m_MandatoryStringArray, value.m_MandatoryStringArray)) return false;
            if (IsOptionalStringArraySet())
            {
                if (!TypeUtils.IsEqual(m_OptionalStringArray, value.m_OptionalStringArray)) return false;
            }

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            StructureWithOptionalFields clone = (StructureWithOptionalFields)this.MemberwiseClone();

            clone.m_encodingMask = m_encodingMask;
            clone.m_MandatoryInt32 = (int)TypeUtils.Clone(this.m_MandatoryInt32);
            clone.m_OptionalInt32 = (int?)TypeUtils.Clone(this.m_OptionalInt32);
            clone.m_MandatoryStringArray = (StringCollection)TypeUtils.Clone(this.m_MandatoryStringArray);
            clone.m_OptionalStringArray = (StringCollection)TypeUtils.Clone(this.m_OptionalStringArray);

            return clone;
        }
        #endregion

        #region Private Fields
        protected uint m_encodingMask;
        private int m_MandatoryInt32;
        private int? m_OptionalInt32;
        private StringCollection m_MandatoryStringArray;
        private StringCollection m_OptionalStringArray;
        #endregion
    }

    #region StructureWithOptionalFieldsCollection class
    /// <summary>
    /// A collection of StructureWithOptionalFields objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfStructureWithOptionalFields", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "StructureWithOptionalFields")]
    public partial class StructureWithOptionalFieldsCollection : List<StructureWithOptionalFields>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public StructureWithOptionalFieldsCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public StructureWithOptionalFieldsCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public StructureWithOptionalFieldsCollection(IEnumerable<StructureWithOptionalFields> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator StructureWithOptionalFieldsCollection(StructureWithOptionalFields[] values)
        {
            if (values != null)
            {
                return new StructureWithOptionalFieldsCollection(values);
            }

            return new StructureWithOptionalFieldsCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator StructureWithOptionalFields[](StructureWithOptionalFieldsCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            StructureWithOptionalFieldsCollection clone = new StructureWithOptionalFieldsCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((StructureWithOptionalFields)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region UnionTest Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class UnionTest : UnifiedAutomation.UaBase.Union, UnifiedAutomation.UaBase.IEncodeableUnion
    {
        #region Union Type
        public enum UnionTestType : uint
        {
            Null = 0,
            Int32 = 1,
            String = 2,
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public UnionTest()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_switchField = UnionTestType.Null;
            m_value = null;
        }
        #endregion

        #region Public Properties
        [DataMember(Name = "SwitchField", IsRequired = false, Order = 1)]
        private uint SwitchField
        {
            get
            {
                return (uint)m_switchField;
            }
            set
            {
                m_switchField = (UnionTestType)value;
            }
        }

        uint IEncodeableUnion.SwitchField => SwitchField;

        UnifiedAutomation.UaBase.TypeInfo IEncodeableUnion.GetTypeInfo(uint switchField)
        {
            switch ((UnionTestType)switchField)
            {
                case UnionTestType.Int32:
                    return UnifiedAutomation.UaBase.TypeInfo.Scalars.Int32;
                case UnionTestType.String:
                    return UnifiedAutomation.UaBase.TypeInfo.Scalars.String;
                case UnionTestType.Null:
                default:
                    return null;
            }
        }

        /// <summary>
        /// Returns the current UnionTestType.
        /// </summary>
        public UnionTestType Type
        {
            get { return m_switchField; }
        }

        /// <summary>
        /// Returns the current data.
        /// </summary>
        public object Value
        {
            get { return m_value; }
        }

        [DataMember(Name = "Int32", IsRequired = false, Order = 2)]
        /// <summary>
        /// </summary>
        public int? Int32
        {
            get
            {
                if (m_switchField == UnionTestType.Int32)
                {
                    return (int?) m_value;
                }
                return null;
            }
            set
            {
                m_value = value;
                m_switchField = UnionTestType.Int32;
            }
        }

        [DataMember(Name = "String", IsRequired = false, Order = 2)]
        /// <summary>
        /// </summary>
        public string String
        {
            get
            {
                if (m_switchField == UnionTestType.String)
                {
                    return (string) m_value;
                }
                return null;
            }
            set
            {
                m_value = value;
                m_switchField = UnionTestType.String;
            }
        }
        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.UnionTest; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.UnionTest_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.UnionTest_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteUInt32("SwitchField", (uint)m_switchField);

            string fieldName = encoder.UnionFieldName;

            switch (m_switchField)
            {
                case UnionTestType.Null:
                    break;
                case UnionTestType.Int32:
                    encoder.WriteInt32(fieldName ?? "Int32", (int) m_value);
                    break;
                case UnionTestType.String:
                    encoder.WriteString(fieldName ?? "String", (string) m_value);
                    break;
            }

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            m_switchField = (UnionTestType)decoder.ReadUInt32("SwitchField");
            string fieldName = decoder.UnionFieldName;

            switch (m_switchField)
            {
                case UnionTestType.Null:
                    m_value = null;
                    break;
                case UnionTestType.Int32:
                    m_value = decoder.ReadInt32(fieldName ?? "Int32");
                    break;
                case UnionTestType.String:
                    m_value = decoder.ReadString(fieldName ?? "String");
                    break;
            }
            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            UnionTest value = encodeable as UnionTest;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;

            if (!TypeUtils.IsEqual(m_switchField, value.m_switchField)) return false;
            if (!TypeUtils.IsEqual(m_value, value.m_value)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            UnionTest clone = (UnionTest)base.Clone();

            clone.m_switchField = (UnionTestType)TypeUtils.Clone(this.m_switchField);
            switch (m_switchField)
            {
                case UnionTestType.Int32:
                    clone.m_value = TypeUtils.Clone(this.m_value);
                    break;
                case UnionTestType.String:
                    clone.m_value = TypeUtils.Clone(this.m_value);
                    break;
            }

            return clone;
        }
        #endregion

        #region Private Fields
        private UnionTestType m_switchField;
        private object m_value;
        #endregion
    }

    #region UnionTestCollection class
    /// <summary>
    /// A collection of UnionTest objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfUnionTest", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "UnionTest")]
    public partial class UnionTestCollection : List<UnionTest>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public UnionTestCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public UnionTestCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public UnionTestCollection(IEnumerable<UnionTest> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator UnionTestCollection(UnionTest[] values)
        {
            if (values != null)
            {
                return new UnionTestCollection(values);
            }

            return new UnionTestCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator UnionTest[](UnionTestCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            UnionTestCollection clone = new UnionTestCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((UnionTest)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region Vector Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class Vector : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public Vector()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_X = 0.0;
            m_Y = 0.0;
            m_Z = 0.0;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "X", IsRequired = false, Order = 1)]
        public double X
        {
            get
            {
                return m_X;
            }
            set
            {
                m_X = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Y", IsRequired = false, Order = 2)]
        public double Y
        {
            get
            {
                return m_Y;
            }
            set
            {
                m_Y = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Z", IsRequired = false, Order = 3)]
        public double Z
        {
            get
            {
                return m_Z;
            }
            set
            {
                m_Z = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.Vector; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.Vector_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.Vector_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteDouble("X", X);
            encoder.WriteDouble("Y", Y);
            encoder.WriteDouble("Z", Z);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            X = decoder.ReadDouble("X");
            Y = decoder.ReadDouble("Y");
            Z = decoder.ReadDouble("Z");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            Vector value = encodeable as Vector;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_X, value.m_X)) return false;
            if (!TypeUtils.IsEqual(m_Y, value.m_Y)) return false;
            if (!TypeUtils.IsEqual(m_Z, value.m_Z)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            Vector clone = (Vector)this.MemberwiseClone();

            clone.m_X = (double)TypeUtils.Clone(this.m_X);
            clone.m_Y = (double)TypeUtils.Clone(this.m_Y);
            clone.m_Z = (double)TypeUtils.Clone(this.m_Z);

            return clone;
        }
        #endregion

        #region Private Fields
        private double m_X;
        private double m_Y;
        private double m_Z;
        #endregion
    }

    #region VectorCollection class
    /// <summary>
    /// A collection of Vector objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfVector", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "Vector")]
    public partial class VectorCollection : List<Vector>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public VectorCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public VectorCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public VectorCollection(IEnumerable<Vector> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator VectorCollection(Vector[] values)
        {
            if (values != null)
            {
                return new VectorCollection(values);
            }

            return new VectorCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator Vector[](VectorCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            VectorCollection clone = new VectorCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((Vector)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region WorkOrderStatusType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class WorkOrderStatusType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public WorkOrderStatusType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Actor = null;
            m_Timestamp = DateTime.MinValue;
            m_Comment = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Actor", IsRequired = false, Order = 1)]
        public string Actor
        {
            get
            {
                return m_Actor;
            }
            set
            {
                m_Actor = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Timestamp", IsRequired = false, Order = 2)]
        public DateTime Timestamp
        {
            get
            {
                return m_Timestamp;
            }
            set
            {
                m_Timestamp = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Comment", IsRequired = false, Order = 3)]
        public LocalizedText Comment
        {
            get
            {
                return m_Comment;
            }
            set
            {
                m_Comment = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.WorkOrderStatusType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.WorkOrderStatusType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.WorkOrderStatusType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteString("Actor", Actor);
            encoder.WriteDateTime("Timestamp", Timestamp);
            encoder.WriteLocalizedText("Comment", Comment);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            Actor = decoder.ReadString("Actor");
            Timestamp = decoder.ReadDateTime("Timestamp");
            Comment = decoder.ReadLocalizedText("Comment");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            WorkOrderStatusType value = encodeable as WorkOrderStatusType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_Actor, value.m_Actor)) return false;
            if (!TypeUtils.IsEqual(m_Timestamp, value.m_Timestamp)) return false;
            if (!TypeUtils.IsEqual(m_Comment, value.m_Comment)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            WorkOrderStatusType clone = (WorkOrderStatusType)this.MemberwiseClone();

            clone.m_Actor = (string)TypeUtils.Clone(this.m_Actor);
            clone.m_Timestamp = (DateTime)TypeUtils.Clone(this.m_Timestamp);
            clone.m_Comment = (LocalizedText)TypeUtils.Clone(this.m_Comment);

            return clone;
        }
        #endregion

        #region Private Fields
        private string m_Actor;
        private DateTime m_Timestamp;
        private LocalizedText m_Comment;
        #endregion
    }

    #region WorkOrderStatusTypeCollection class
    /// <summary>
    /// A collection of WorkOrderStatusType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfWorkOrderStatusType", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "WorkOrderStatusType")]
    public partial class WorkOrderStatusTypeCollection : List<WorkOrderStatusType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public WorkOrderStatusTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public WorkOrderStatusTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public WorkOrderStatusTypeCollection(IEnumerable<WorkOrderStatusType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator WorkOrderStatusTypeCollection(WorkOrderStatusType[] values)
        {
            if (values != null)
            {
                return new WorkOrderStatusTypeCollection(values);
            }

            return new WorkOrderStatusTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator WorkOrderStatusType[](WorkOrderStatusTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            WorkOrderStatusTypeCollection clone = new WorkOrderStatusTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((WorkOrderStatusType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region WorkOrderType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Demo.Model.Namespaces.ModelXsd)]
    public partial class WorkOrderType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public WorkOrderType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_ID = Uuid.Empty;
            m_AssetID = null;
            m_StartTime = DateTime.MinValue;
            m_StatusComments = new WorkOrderStatusTypeCollection();
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "ID", IsRequired = false, Order = 1)]
        public Uuid ID
        {
            get
            {
                return m_ID;
            }
            set
            {
                m_ID = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "AssetID", IsRequired = false, Order = 2)]
        public string AssetID
        {
            get
            {
                return m_AssetID;
            }
            set
            {
                m_AssetID = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "StartTime", IsRequired = false, Order = 3)]
        public DateTime StartTime
        {
            get
            {
                return m_StartTime;
            }
            set
            {
                m_StartTime = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "StatusComments", IsRequired = false, Order = 4)]
        public WorkOrderStatusTypeCollection StatusComments
        {
            get
            {
                return m_StatusComments;
            }
            set
            {
                m_StatusComments = value;

                if (value == null)
                {
                    m_StatusComments = new WorkOrderStatusTypeCollection();
                }
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return UnifiedAutomation.Demo.Model.DataTypeIds.WorkOrderType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.WorkOrderType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return UnifiedAutomation.Demo.Model.ObjectIds.WorkOrderType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);

            encoder.WriteGuid("ID", ID);
            encoder.WriteString("AssetID", AssetID);
            encoder.WriteDateTime("StartTime", StartTime);
            encoder.WriteEncodeableArray("StatusComments", StatusComments.ToArray(), typeof(WorkOrderStatusType));

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(UnifiedAutomation.Demo.Model.Namespaces.ModelXsd);
            ID = decoder.ReadGuid("ID");
            AssetID = decoder.ReadString("AssetID");
            StartTime = decoder.ReadDateTime("StartTime");
            StatusComments = (WorkOrderStatusTypeCollection) decoder.ReadEncodeableArray("StatusComments", typeof(WorkOrderStatusType));

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            WorkOrderType value = encodeable as WorkOrderType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_ID, value.m_ID)) return false;
            if (!TypeUtils.IsEqual(m_AssetID, value.m_AssetID)) return false;
            if (!TypeUtils.IsEqual(m_StartTime, value.m_StartTime)) return false;
            if (!TypeUtils.IsEqual(m_StatusComments, value.m_StatusComments)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            WorkOrderType clone = (WorkOrderType)this.MemberwiseClone();

            clone.m_ID = (Uuid)TypeUtils.Clone(this.m_ID);
            clone.m_AssetID = (string)TypeUtils.Clone(this.m_AssetID);
            clone.m_StartTime = (DateTime)TypeUtils.Clone(this.m_StartTime);
            clone.m_StatusComments = (WorkOrderStatusTypeCollection)TypeUtils.Clone(this.m_StatusComments);

            return clone;
        }
        #endregion

        #region Private Fields
        private Uuid m_ID;
        private string m_AssetID;
        private DateTime m_StartTime;
        private WorkOrderStatusTypeCollection m_StatusComments;
        #endregion
    }

    #region WorkOrderTypeCollection class
    /// <summary>
    /// A collection of WorkOrderType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfWorkOrderType", Namespace = UnifiedAutomation.Demo.Model.Namespaces.Model, ItemName = "WorkOrderType")]
    public partial class WorkOrderTypeCollection : List<WorkOrderType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public WorkOrderTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public WorkOrderTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public WorkOrderTypeCollection(IEnumerable<WorkOrderType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator WorkOrderTypeCollection(WorkOrderType[] values)
        {
            if (values != null)
            {
                return new WorkOrderTypeCollection(values);
            }

            return new WorkOrderTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator WorkOrderType[](WorkOrderTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            WorkOrderTypeCollection clone = new WorkOrderTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((WorkOrderType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion


    #region EncodeableTypes
    /// <summary>
    /// Contains a method for registering all encodeable types of the namespace.
    /// </summary>
    public class EncodeableTypes
    {
        /// <summary>
        /// Register all encodeable types of the namespace at the communication stack.
        /// The Decoder will decode the registered types.
        /// </summary>
        public static void RegisterEncodeableTypes(MessageContext context)
        {
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.ConcreteSubType));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.ExtendedSubType));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.AccessRights));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.OptionSetBase));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.StructureWithAbstractBaseTypes));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.StructureWithAllowSubtypes));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.StructureWithDerivedStructures));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.StructureWithDifferentDataTypes));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.StructureWithOptionalFields));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.UnionTest));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.Vector));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.WorkOrderStatusType));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Demo.Model.WorkOrderType));
        }
    }
    #endregion
}
