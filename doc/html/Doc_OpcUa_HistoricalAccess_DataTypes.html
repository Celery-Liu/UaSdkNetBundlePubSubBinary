<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>.NET Based OPC UA Client/Server/PubSub SDK: Data Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header_inner_inner_bg2.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">.NET Based OPC UA Client/Server/PubSub SDK
   &#160;<span id="projectnumber">4.1.0.556</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Doc_OpcUa_HistoricalAccess_DataTypes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Data Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails">ReadEventDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails">ReadRawModifiedDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadProcessedDetails">ReadProcessedDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadAtTimeDetails">ReadAtTimeDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEvent">HistoryEvent</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_PerformUpdateType">PerformUpdateType</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateDataDetails">UpdateDataDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateStructureDataDetails">UpdateStructureDataDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateEventDetails">UpdateEventDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_DeleteRawModifiedDetails">DeleteRawModifiedDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_DeleteAtTimeDetails">DeleteAtTimeDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_DeleteEventDetails">DeleteEventDetails</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEventFieldList">HistoryEventFieldList</a></li>
<li><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_Annotation">Annotation</a></li>
</ul>
<h1><a class="anchor" id="Doc_OpcUa_ReadEventDetails"></a>
ReadEventDetails</h1>
<p>Selects a set of events from the history database by specifying a filter and a time domain for one or more objects or views.</p>
<p>The ReadEventDetails structure is used to read the events from the history database for the specified time domain for one or more HistoricalEventNodes. The events are filtered based on the filter structure provided. This filter includes the event fields that are to be returned.</p>
<p>The startTime and endTime are used to filter on the Time field for events.</p>
<p>The time domain of the request is defined by startTime, endTime, and numValuesPerNode; at least two of these must be specified. If endTime is less than startTime, or endTime and numValuesPerNode alone are specified, the data will be returned in reverse order with later/newer data provided first, as if time was flowing backward. If all three are specified, the call shall return up to numValuesPerNode results, going from startTime to endTime, in either ascending or descending order, depending on the relative values of startTime and endTime. If numValuesPerNode is 0, all of the values in the range are returned. The default value is used to indicate that startTime, endTime, or numValuesPerNode is not specified.</p>
<p>It is specifically allowed for the startTime and the endTime to be identical. This allows the Client to request the event at a single instance in time. If startTime and endTime are identical, time is presumed to be flowing forward. If no data exists at the time specified, the server must return the Good_NoData StatusCode.</p>
<p>If a startTime, endTime, and numValuesPerNode are all provided, and if more than numValuesPerNode events exist within that time range for a given node, then only numValuesPerNode events per node are returned along with a continuationPoint. When a continuationPoint is returned, a Client wanting the next numValuesPerNode values should call HistoryRead again with the continuationPoint.</p>
<p>For an interval in which no data exists, the corresponding StatusCode shall be Good_NoData.</p>
<p>The filter parameter is used to determine which historical events and their corresponding fields are returned. It is possible that the fields of an EventType are available for real time updating, but not available from the historian. In this case, a StatusCode value will be returned for any event field that cannot be returned. The value of the StatusCode must be Bad_NoData.</p>
<p>If the requested timestamp format is not supported for a node, the operation shall return the Bad_TimestampNotSupported StatusCode. When reading events, this only applies to Event fields that are of type DataValue.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_NumValuesPerNode">NumValuesPerNode</a> </td><td>UInt32 </td><td>Scalar </td><td>The maximum number of values returned for any node over the time range. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_NumValuesPerNode">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_StartTime">StartTime</a> </td><td>DateTime </td><td>Scalar </td><td>The beginning of the period to read. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_StartTime">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_EndTime">EndTime</a> </td><td>DateTime </td><td>Scalar </td><td>The end of the period to read. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_EndTime">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_Filter">Filter</a> </td><td><a class="el" href="Doc_OpcUa_Services_DataTypes.html#Doc_OpcUa_EventFilter">EventFilter</a> </td><td>Scalar </td><td>A filter used by the Server to determine which HistoricalEventNode should be included. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadEventDetails_Filter">More...</a> </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_ReadEventDetails_NumValuesPerNode"></a>
NumValuesPerNode</h2>
<p>The maximum number of values returned for any node over the time range.</p>
<p>If only one time is specified, the time range must extend to return this number of values. The default value of 0 indicates that there is no maximum.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadEventDetails_StartTime"></a>
StartTime</h2>
<p>The beginning of the period to read.</p>
<p>The default value of DateTime.MinValue indicates that the startTime is Unspecified.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadEventDetails_EndTime"></a>
EndTime</h2>
<p>The end of the period to read.</p>
<p>The default value of DateTime.MinValue indicates that the endTime is Unspecified.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadEventDetails_Filter"></a>
Filter</h2>
<p>A filter used by the Server to determine which HistoricalEventNode should be included.</p>
<p>This parameter must be specified and at least one EventField is required. The EventFilter parameter type is an extensible parameter type. It is defined and used in the same manner as defined for monitored data items. This filter also specifies the EventFields that are to be returned as part of the request.</p>
<h1><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails"></a>
ReadRawModifiedDetails</h1>
<p>Selects a set of raw or modified values from the history database by specifying a time domain for one or more variables.</p>
<p><b>Read raw functionality</b></p>
<p>When this structure is used for reading Raw Values, it reads the values, qualities, and timestamps from the history database for the specified time domain for one or more HistoricalDataNodes. This parameter is intended for use by a Client that wants the actual data saved within the historian. The actual data may be compressed or may be all raw data collected for the item depending on the historian and the storage rules invoked when the item values were saved. When returnBounds is TRUE, the bounding values for the time domain are returned. The optional bounding values are provided to allow the Client to interpolate values for the start and end times when trending the actual data on a display.</p>
<p>The time domain of the request is defined by startTime, endTime, and numValuesPerNode; at least two of these must be specified. If endTime is less than startTime, or endTime and numValuesPerNode alone are specified, the data will be returned in reverse order, with later data coming first, as if time was flowing backward. If all three are specified, the call shall return up to numValuesPerNode results going from startTime to endTime, in either ascending or descending order, depending on the relative values of startTime and endTime. If numValuesPerNode is 0, all the values in the range are returned. A default value of DateTime.MinValue is used to indicate that startTime or endTime are not specified.</p>
<p>It is specifically allowed for the startTime and the endTime to be identical. This allows the Client to request just one value. If startTime and endTime are identical, time is presumed to be flowing forward. It is specifically not allowed for the server to return a Bad_InvalidArgument StatusCode if the requested time domain is outside of the server’s range. Such a case shall be treated as an interval in which no data exists.</p>
<p>If startTime, endTime, and numValuesPerNode are all provided and if more than numValuesPerNode values exist within that time range for a given node, only numValuesPerNode values per node are returned along with a continuationPoint. When a continuationPoint is returned, a Client wanting the next numValuesPerNode values should call ReadRaw again with the continuationPoint set.</p>
<p>If Bounding Values are requested and a non-zero numValuesPerNode was specified, any bounding values returned are included in the numValuesPerNode count. If numValuesPerNode is 1, only the start bound is returned (the end bound if reverse order is needed). If numValuesPerNode is 2, the start bound and the first data point are returned (the end bound if reverse order is needed). When bounding values are requested and no bounding value is found, the corresponding StatusCode entry will be set to Bad_BoundNotFound, a timestamp equal to the start or end time as appropriate, and a value of null. How far back or forward to look in history for bounding values is server dependent.</p>
<p>For an interval in which no data exists, if bounding values are not requested, the corresponding StatusCode must be Good_NoData. If bounding values are requested and one or both exist, then the result code returned is Success and the bounding value(s) are returned.</p>
<p>For cases where there are multiple values for a given timestamp, all but the most recent are considered to be modified values and the server must return the most recent value. If the server returns a value which hides other values at a timestamp, it must set the ExtraData bit in the StatusCode associated with that value. If the Server contains additional information regarding a value, the ExtraData bit shall also be set. This indicates that ModifiedValues are available for retrieval.</p>
<p>If the requested timestamp format is not supported for a node, the operation shall return the Bad_TimestampNotSupported StatusCode.</p>
<p><b>Read modified functionality</b></p>
<p>When this structure is used for reading modified values, it reads the values, StatusCodes, timestamps, modification type, the user identifier, and the timestamp of the modification from the history database for the specified time domain for one or more HistoricalDataNodes. If there are multiple replaced values, the server must return all of them. The updateType specifies which value is returned in the modification record. If the updateType is INSERT, the value is the new value that was inserted. If the updateType is anything else, the value is the old value that was changed.</p>
<p>The purpose of this function is to read values from history that have been modified. The returnBounds parameter must be set to FALSE for this case, otherwise the server returns a Bad_InvalidArgument StatusCode.</p>
<p>The domain of the request is defined by startTime, endTime, and numValuesPerNode; at least two of these must be specified. If endTime is less than startTime, or endTime and numValuesPerNode alone are specified, the data shall be returned in reverse order with later data coming first. If all three are specified, the call shall return up to numValuesPerNode results going from StartTime to EndTime, in either ascending or descending order, depending on the relative values of StartTime and EndTime. If more than numValuesPerNode values exist within that time range for a given Node, only numValuesPerNode values per node are returned along with a continuationPoint. If a continuationPoint is returned, a Client wanting the next numValuesPerNode values should call ReadRaw again with the continuationPoint set. If numValuesPerNode is 0, all of the values in the range are returned. If the Server cannot return all modified values for a given timestamp in a single response, it shall return modified values with the same timestamp in subsequent calls.</p>
<p>If a value has been modified multiple times, all values for the time are returned. This means that a timestamp can appear in the array more than once. The order of the returned values with the same timestamp should be from the most recent to oldest modification timestamp if startTime is less than or equal to endTime. If endTime is less than startTime, the order of the returned values will be from the oldest modificfication timestamp to the most recent. It is server dependent whether multiple modifications are kept or only the most recent.</p>
<p>A server does not have to create a modification record for data when it is first added to the historical collection. If it does, it shall set the ExtraData bit and the Client can read the modification record using a ReadModified call. If the data is subsequently modified, the server shall create a second modification record, which is returned along with the original modification record whenever a Client uses the ReadModified call if the Server supports multiple modification records per timestamp.</p>
<p>If the requested timestamp format is not supported for a Node, the operation shall return the Bad_TimestampNotSupported StatusCode.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_IsReadModified">IsReadModified</a> </td><td>Boolean </td><td>Scalar </td><td>TRUE for read modified functionality, FALSE for read raw functionality. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_IsReadModified">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_StartTime">StartTime</a> </td><td>DateTime </td><td>Scalar </td><td>The beginning of the period to read. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_StartTime">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_EndTime">EndTime</a> </td><td>DateTime </td><td>Scalar </td><td>The end of the period to read. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_EndTime">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_NumValuesPerNode">NumValuesPerNode</a> </td><td>UInt32 </td><td>Scalar </td><td>The maximum number of values returned for any node over the time range. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_NumValuesPerNode">More...</a> </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_ReturnBounds">ReturnBounds</a> </td><td>Boolean </td><td>Scalar </td><td>A boolean parameter indicating whether bounding values should be returned. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadRawModifiedDetails_ReturnBounds">More...</a> </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails_IsReadModified"></a>
IsReadModified</h2>
<p>TRUE for read modified functionality, FALSE for read raw functionality.</p>
<p>The default value is FALSE.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails_StartTime"></a>
StartTime</h2>
<p>The beginning of the period to read.</p>
<p>Set to default value of DateTime.MinValue if no specific start time is specified.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails_EndTime"></a>
EndTime</h2>
<p>The end of the period to read.</p>
<p>Set to default value of DateTime.MinValue if no specific end time is specified.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails_NumValuesPerNode"></a>
NumValuesPerNode</h2>
<p>The maximum number of values returned for any node over the time range.</p>
<p>If only one time is specified, the time range must extend to return this number of values. The default value 0 indicates that there is no maximum.</p>
<h2><a class="anchor" id="Doc_OpcUa_ReadRawModifiedDetails_ReturnBounds"></a>
ReturnBounds</h2>
<p>A boolean parameter indicating whether bounding values should be returned.</p>
<p>It has the following values </p><dl>
<dt>TRUE </dt>
<dd>bounding values should be returned </dd>
<dt>FALSE </dt>
<dd>all other cases </dd>
</dl>
<h1><a class="anchor" id="Doc_OpcUa_ReadProcessedDetails"></a>
ReadProcessedDetails</h1>
<p>Selects a set of aggregate values from the history database by specifying a time domain for one or more variables.</p>
<p>This structure is used to compute aggregate values, qualities, and timestamps from data in the history database for the specified time domain for one or more HistoricalDataNodes. The time domain is divided into intervals of duration ProcessingInterval. The specified AggregateType is calculated for each interval beginning with startTime by using the data within the next ProcessingInterval.</p>
<p>For example, this function can provide hourly statistics such as maximum, minimum, and average for each item during the specified time domain if ProcessingInterval is 1 hour.</p>
<p>The domain of the request is defined by startTime, endTime, and ProcessingInterval. All three must be specified. If endTime is less than startTime, the data shall be returned in reverse order with later data coming first. If startTime and endTime are the same, the server shall return Bad_InvalidArgument, as there is no meaningful way to interpret such a case.</p>
<p>The aggregateType[] parameter allows a Client to request multiple aggregate calculations per requested NodeId. If multiple aggregates are requested, a corresponding number of entries are required in the NodesToRead array.</p>
<p>For example, requesting Min aggregate for NodeId FIC101, FIC102 and both Min and Max aggregates for NodeId FIC103 would require NodeId FIC103 to appear twice in the NodesToRead array request parameter.</p>
<table class="doxtable">
<tr>
<th>aggregateType[] </th><th>NodesToRead[]  </th></tr>
<tr>
<td>Min </td><td>FIC101 </td></tr>
<tr>
<td>Min </td><td>FIC102 </td></tr>
<tr>
<td>Min </td><td>FIC103 </td></tr>
<tr>
<td>Max </td><td>FIC103 </td></tr>
</table>
<p>If the array of aggregates does not match the array of NodesToRead, the Server shall return a StatusCode of Bad_AggregateListMismatch. The aggregateConfiguration parameter allows a Client to override the aggregate configuration settings supplied by the AggregateConfiguration object on a per call basis. If the Server does not support the ability to override the aggregate configuration settings, it shall return a StatusCode of Bad_AggregateConfigurationRejected. If the aggregate is not valid for the node, the StatusCode shall be Bad_AggregateNotSupported.</p>
<p>The values used in computing the aggregate for each interval shall include any value that falls exactly on the timestamp at beginning of the interval, but shall not include any value that falls directly on the timestamp ending the interval. Thus, each value shall be included only once in the calculation. If the time domain is in reverse order, we consider the later timestamp to be the one beginning the subinterval, and the earlier timestamp to be the one ending it. Note that this means that simply swapping the start and end times will not result in getting the same values back in reverse order, as the interval being requested in the two cases are not the same.</p>
<p>If an aggregate is taking a long time to calculate, the Server can return partial results with a continuation point. This might be done if the calculation is going to take more time than the Client timeout hint. In some cases it may take longer than the Client timeout hint to calculate even one Aggregate result. Then the server may return zero results with a continuation point that allows the server to resume the calculation on the next Client read call.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>StartTime </td><td>DateTime </td><td>Scalar </td><td>The beginning of the period to read. </td></tr>
<tr>
<td>EndTime </td><td>DateTime </td><td>Scalar </td><td>The end of the period to read. </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadProcessedDetails_ProcessingInterval">ProcessingInterval</a> </td><td>Double </td><td>Scalar </td><td>The interval between returned aggregate values. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_ReadProcessedDetails_ProcessingInterval">More...</a> </td></tr>
<tr>
<td>AggregateType </td><td>NodeId </td><td>Array </td><td>The NodeId of the HistoryAggregate object that indicates the list of aggregates to be used when retrieving processed history. </td></tr>
<tr>
<td>AggregateConfiguration </td><td><a class="el" href="Doc_OpcUa_Services_DataTypes.html#Doc_OpcUa_AggregateConfiguration">AggregateConfiguration</a> </td><td>Scalar </td><td>Allows a Client to override aggregate configuration settings ona per call basis. </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_ReadProcessedDetails_ProcessingInterval"></a>
ProcessingInterval</h2>
<p>The interval between returned aggregate values.</p>
<p>The value 0 indicates that there is no ProcessingInterval defined.</p>
<h1><a class="anchor" id="Doc_OpcUa_ReadAtTimeDetails"></a>
ReadAtTimeDetails</h1>
<p>Selects a set of raw or interpolated values from the history database by specifying a series of timestamps for one or more variables.</p>
<p>The ReadAtTimeDetails structure reads the values and qualities from the history database for the specified timestamps for one or more HistoricalDataNodes. This function is intended to provide values to correlate with other values with a known timestamp. For example, a Client may need to read the values of sensors when lab samples were collected.</p>
<p>The order of the values and qualities returned shall match the order of the timestamps supplied in the request.</p>
<p>If no value exists for a specified timestamp, a value shall be interpolated from the surrounding values to represent the value at the specified timestamp. The interpolation will follow the same rules as the standard interpolated aggregate as outlined in Part 13 of the OPC UA specification.</p>
<p>If the useSimpleBounds flag is True and interpolation is required, SimpleBounds will be used to calculate the data value.</p>
<p>If a value is found for the specified timestamp, the server will set the StatusCode InfoBits to be Raw. If the value is interpolated from the surrounding values, the server will set the StatusCode InfoBits to be Interpolated.</p>
<p>If the requested timestamp format is not supported for a node, the operation shall return the Bad_TimestampNotSupported StatusCode.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>ReqTimes </td><td>DateTime </td><td>Array </td><td>Defines the specific timestamps for which values are to be read. </td></tr>
<tr>
<td>UseSimpleBounds </td><td>Boolean </td><td>Scalar </td><td>Use simple bounds to determine the value at the specific timestamp. </td></tr>
</table>
<h1><a class="anchor" id="Doc_OpcUa_HistoryEvent"></a>
HistoryEvent</h1>
<p>A table structure that is used to return Event fields to a Historical Read.</p>
<p>The structure is in the form of a table consisting of one or more Events, each containing an array of one or more fields. The selection and order of the fields returned for each Event is identical to the selected parameter of the EventFilter.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>Events </td><td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEventFieldList">HistoryEventFieldList</a> </td><td>Array </td><td>The list of Events being delivered </td></tr>
</table>
<h1><a class="anchor" id="Doc_OpcUa_PerformUpdateType"></a>
PerformUpdateType</h1>
<table class="doxtable">
<tr>
<th>Enum String </th><th>Enum Value </th><th>Description  </th></tr>
<tr>
<td>Insert </td><td>1 </td><td>Data was inserted </td></tr>
<tr>
<td>Replace </td><td>2 </td><td>Data was replaced </td></tr>
<tr>
<td>Update </td><td>3 </td><td>Data was inserted or replaced </td></tr>
<tr>
<td>Remove </td><td>4 </td><td>Data was deleted </td></tr>
</table>
<h1><a class="anchor" id="Doc_OpcUa_UpdateDataDetails"></a>
UpdateDataDetails</h1>
<p>The details for insert, replace, and insert/replace history updates.</p>
<p><b>Insert data functionality</b><br />
 Setting performInsertReplace = INSERT_1 inserts entries into the history database at the specified timestamps for one or more HistoricalDataNodes. If an entry exists at the specified timestamp, the new entry shall not be inserted; instead the StatusCode shall indicate Bad_EntryExists.</p>
<p>This function is intended to insert new entries at the specified timestamps; e.g. the insertion of lab data to reflect the time of data collection.</p>
<p><b>Replace data functionality</b><br />
 Setting performInsertReplace = REPLACE_2 replaces entries in the history database at the specified timestamps for one or more HistoricalDataNodes. If no entry exists at the specified timestamp, the new entry shall not be inserted; otherwise the StatusCode shall indicate Bad_NoEntryExists.</p>
<p>This function is intended to replace existing entries at the specified timestamp; e.g., correct lab data that was improperly processed, but inserted into the history database.</p>
<p><b>Update data functionality</b><br />
 Setting performInsertReplace = UPDATE_3 inserts or replaces entries in the history database for the specified timestamps for one or more HistoricalDataNodes. If the item has an entry at the specified timestamp, the new entry will replace the old one. If there is no entry at that timestamp, the function will insert the new data.</p>
<p>A Server can create a modified value for a value being replaced or inserted, however it is not required.</p>
<p>This function is intended to unconditionally insert/replace values and qualities; e.g., correction of values for bad sensors.</p>
<p>Good as a StatusCode for an individual entry is allowed when the server is unable to say whether there was already a value at that timestamp. If the server can determine whether the new entry replaces an entry that was already there, it should use Good_EntryInserted or Good_EntryReplaced to return that information.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>Node ID of the object to be updated. </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateDataDetails_PerformInsertReplace">PerformInsertReplace</a> </td><td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_PerformUpdateType">PerformUpdateType</a> </td><td>Scalar </td><td>Determines which action of insert, replace, or update is performed. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateDataDetails_PerformInsertReplace">More...</a> </td></tr>
<tr>
<td>UpdateValues </td><td>DataValue </td><td>Array </td><td>New values to be inserted or to replace. </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_UpdateDataDetails_PerformInsertReplace"></a>
PerformInsertReplace</h2>
<p>Determines which action of insert, replace, or update is performed.</p>
<p>Possible values are INSERT_1, REPLACE_2, or UPDATE_3, see <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateDataDetails">UpdateDataDetails</a></p>
<h1><a class="anchor" id="Doc_OpcUa_UpdateStructureDataDetails"></a>
UpdateStructureDataDetails</h1>
<p>This function inserts, replaces or removes structured history data or annotations into the history database at the specified timestamps for one or more HistoricalDataNodes.</p>
<p>Structured history data provides metadata describing an entry in the history database. The server shall define what uniqueness means for each structured history data structure type. For example, a server may only allow one annotation per timestamp, which means the timestamp is the unique key for the structure. Another server may allow for multiple annotations to exist per user, so a combination of a username, timestamp, and message may be used as the unique key for the structure. In the following sections the terms “Structured Histroy Data exists” and “at the specificed parameters” means a matching entry has been found at the specified timestamp using the Server’s criteria for uniqueness.</p>
<p>In the case where the Client wishes to replace a parameter that is part of the uniqueness criteria, the resulting StatusCode would be Bad_NoEntryExists. The Client must remove the existing structure and then insert the new structure.</p>
<p><b>Insert functionality</b><br />
 Setting performInsertReplace = INSERT_1 inserts structured history data, such as annotations, into the history database at the specified parameters for one or more properties of HistoricalDataNodes.</p>
<p>If a structured history data entry already exists at the specified parameters, the StatusCode shall indicate Bad_EntryExists.</p>
<p><b>Replace functionality</b><br />
 Setting performInsertReplace = REPLACE_2 replaces structured history data such as annotations in the history database at the specified parameters for one or more properties of HistoricalDataNodes.</p>
<p>If a structured history data entry does not already exist at the specified parameters, the StatusCode shall indicate Bad_NoEntryExists.</p>
<p><b>Update functionality</b><br />
 Setting performInsertReplace = UPDATE_3 inserts or replaces structured history data such as annotations in the history database at the specified parameters for one or more properties of HistoricalDataNodes.</p>
<p>If a structure history data entry already exists at the specified paramters, it is deleted and the value provided by the Client is inserted. If no existing entry exists, the new entry is inserted.</p>
<p>If an existing entry was replaced successfully, the StatusCode shall be Good_EntryReplaced. If a new entry was created, the StatusCode shall be Good_EntryInserted. If the server cannot determine whether it replaced or inserted an entry, the StatusCode shall be Good.</p>
<p><b>Remove functionality</b><br />
 Setting performInsertReplace = REMOVE_4 removes structured history data such as annotations from the history database at the specified parameters for one or more properties of HistoricalDataNodes.</p>
<p>If a structure history data entry exists at the specified parameters, it is deleted. If structured history data does not already exist at the specified parameters, the StatusCode shall indicate Bad_NoEntryExists.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>NodeId of the object to be updated. </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateStructureDataDetails_PerformInsertReplace">PerformInsertReplace</a> </td><td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_PerformUpdateType">PerformUpdateType</a> </td><td>Scalar </td><td>Determines which action of insert, replace, update, or remove is performed. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateStructureDataDetails_PerformInsertReplace">More...</a> </td></tr>
<tr>
<td>UpdateValues </td><td>DataValue </td><td>Array </td><td>New values to be inserted, replaced, or removed. </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_UpdateStructureDataDetails_PerformInsertReplace"></a>
PerformInsertReplace</h2>
<p>Determines which action of insert, replace, update, or remove is performed.</p>
<p>Possible values are INSERT_1, REPLACE_2, UPDATE_3, or REMOVE_4.</p>
<h1><a class="anchor" id="Doc_OpcUa_UpdateEventDetails"></a>
UpdateEventDetails</h1>
<p>This function inserts new events or replaces existing events in the history database for one or more HistoricalEventNodes.</p>
<p><b>Insert event functionality</b><br />
 This function is intended to insert new entries; e.g., backfilling of historical events.</p>
<p>Setting performInsertReplace = INSERT_1 inserts entries into the event history database for one or more HistoricalEventNodes. The whereClause parameter of the EventFilter shall be empty. The SelectClause must as a minimum provide the following event fields: EventType and Time. It is also recommended that the SourceNode and the SourceName fields are provided. If one of the required fields is not provided, the following error is returned: Bad_ArgumentsMissing. If the historian does not support archiving the specified EventType, the StatusCode shall indicate Bad_TypeDefinitionInvalid. If the SourceNode is not a valid source for Events, the StatusCode shall indicate Bad_SourceNodeIdInvalid. If the time does not fall within range that can be stored, the StatusCode shall indicate Bad_OutOfRange. If the selectClause does not include fields which are mandatory for the EventType, the StatusCode shall indicate Bad_ArgumentsMissing. If the selectClause specifies fields which are not valid for the EventType or cannot be saved by the historian, the StatusCode shall indicate Good_DataIgnored and the OperationResults array shall specify Bad_NotSupported for each ignored field.</p>
<p>The EventId is a server generated opaque value and a Client cannot assume that it knows how to create valid EventIds. A Server must be able to generate an appropriate default value for the EventId field. If a Client does specify the EventId in the selectClause and it matches an exitsting event, the StatusCode shall indicate Bad_EntryExists. A Client must use a HistoryRead to discover any automatically generated EventIds.</p>
<p>If any errors occur while processing individual fields, the StatusCode shall indicate Bad_InvalidArgument and the OperationResults array shall specify the exact error for each invalid field. The IndexRange parameter of the SimpleAttributeOperand is not valid for insert operations and the OperationResults shall specify Bad_IndexRangeInvalid if one is specified.</p>
<p>If no errors occur, the StatusCode shall indicate Good and the OperationResults array shall be empty. If errors do occur, the OperationResults array will have one element for each fiel d specified in the selectClause.</p>
<p>A Client may instruct the Server to choose a suitable default value for a field by specifying a value of null. If the server is not able to select a suitable default, the corresponding entry in the OperationResults array shall be Bad_InvalidArgument.</p>
<p><b>Replace event functionality</b><br />
 This function is intended to replace fields in existing event entries; e.g. correct event data that contained incorrect data due to a bad sensor.</p>
<p>Setting performInsertReplace = REPLACE_2 replaces entries in the event history database for the specified filter for one or more HistoricalEventNodes. The whereClause parameter of the EventFilter shall specify the EventId property. If no entry exists matching the specified filter, no updates will be performed; instead the StatusCode shall indicate Bad_NoEntryExists.</p>
<p>If the selectClause specifies fields which are not valid for the EventType or cannot be saved by the historian, the StatusCode shall indicate Good_DataIgnored and the OperationResults array shall specify Bad_NotSupported for each ignored field.</p>
<p>If a field is valid for the EventType but cannot be changed, then the StatusCode shall indicate Good_DataIgnored and the corresponding entry in the OperationResults array shall be Bad_NotWriteable.</p>
<p>If fatal errors occur while processing individual fields, the StatusCode shall indicate Bad_InvalidArgument and the OperationResults array shall specify the exact error.</p>
<p>If no errors occur, the StatusCode shall indicate Good and the OperationResults array shall be empty.If errors do occur, the OperationResults array will have one element for each field specified in the selectClause.</p>
<p><b>Update event functionality</b><br />
 This function is intended to unconditionally insert/replace events, e.g. synchronizing a backup event database.</p>
<p>Setting performInsertReplace = UPDATE_3 inserts or replaces entries in the event history database for the specified filter for one or more HistoricalEventNodes.</p>
<p>The server will, based on its own criteria, attempt to determine whether the event already exists. If it does exist, the event will be deleted and the new event will be inserted (retaining the EventId). If the EventID was provided, the EventID will be used to determine if the event already exists. If the event does not exist, a new event will be inserted, including the generation of a new EventId.</p>
<p>All of the restrictions, behaviours, and errors specified for the insert functionality also apply to this function.</p>
<p>If an existing entry was replaced successfully, the the StatusCode shall be Good_EntryReplaced. If a new entry was created, the StatusCode shall be Good_EntryInserted. If the server cannot determine whether it replaced or inserted an entry, the StatusCode shall be Good.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>NodeId of the object to be updated </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateEventDetails_PerformInsertReplace">PerformInsertReplace</a> </td><td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_PerformUpdateType">PerformUpdateType</a> </td><td>Scalar </td><td>Determines which action of insert, replace, or update is performed. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateEventDetails_PerformInsertReplace">More...</a> </td></tr>
<tr>
<td>Filter </td><td><a class="el" href="Doc_OpcUa_Services_DataTypes.html#Doc_OpcUa_EventFilter">EventFilter</a> </td><td>Scalar </td><td>If the history of the notification conforms to the EventFilter, the history of the notification is updated. </td></tr>
<tr>
<td>EventData </td><td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEventFieldList">HistoryEventFieldList</a> </td><td>Array </td><td>Event notification data to be inserted or updated. </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_UpdateEventDetails_PerformInsertReplace"></a>
PerformInsertReplace</h2>
<p>Determines which action of insert, replace, or update is performed.</p>
<p>Possible values are INSERT_1, REPLACE_2, or UPDATE_3 (see <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_UpdateEventDetails">UpdateEventDetails</a>).</p>
<h1><a class="anchor" id="Doc_OpcUa_DeleteRawModifiedDetails"></a>
DeleteRawModifiedDetails</h1>
<p>The details for delete raw and delete modified history updates.</p>
<p>These functions are intended to be used to delete data that has been accidentally entered into the history database, e.g. deletion of data from a source with incorrect timestamps. Both startTime and endTime must be defined. The startTime must be less than the endTime, and values up to but not including the endTime are deleted. It is permissible for startTime = endTime, in which case the value at the startTime is deleted.</p>
<p><b>Delete raw functionality</b><br />
 Setting isDeleteModified = FALSE deletes all raw entries from the history database for the specified time domain for one more HistoricalDataNodes.</p>
<p>If no data is found in the time range for a particular HistoricalDataNode, the StatusCode for that item is Bad_NoData.</p>
<p><b>Delete modified functionality</b><br />
 Setting isDeleteModified = TRUE deletes all modified entries from the history database for the specified time domain for one or more HistoricalDataNodes. If no data is found in the time range for a particular HistoricalDataNode, the StatusCode for that item is Bad_NoData.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>NodeId of the object for which history values are to be deleted. </td></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_DeleteRawModifiedDetails_IsDeleteModified">IsDeleteModified</a> </td><td>Boolean </td><td>Scalar </td><td>TRUE for MODIFIED, FALSE for RAW. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_DeleteRawModifiedDetails_IsDeleteModified">More...</a> </td></tr>
<tr>
<td>StartTime </td><td>DateTime </td><td>Scalar </td><td>The beginning of the period to be deleted. </td></tr>
<tr>
<td>EndTime </td><td>DateTime </td><td>Scalar </td><td>The end of the period to be deleted. </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_DeleteRawModifiedDetails_IsDeleteModified"></a>
IsDeleteModified</h2>
<p>TRUE for MODIFIED, FALSE for RAW.</p>
<p>Default value is FALSE.</p>
<h1><a class="anchor" id="Doc_OpcUa_DeleteAtTimeDetails"></a>
DeleteAtTimeDetails</h1>
<p>The DeleteAtTime structure deletes all entries in the history database for the specified timestamps for one or more HistoricalDataNodes.</p>
<p>This parameter is intended to be used to delete specific data from the history database, e.g. lab data that is incorrect and cannot be correctly reproduced.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>NodeId of the object for which history values are to be deleted. </td></tr>
<tr>
<td>ReqTimes </td><td>DateTime </td><td>Array </td><td>The entries define the specific timestamps for which values are to be deleted. </td></tr>
</table>
<h1><a class="anchor" id="Doc_OpcUa_DeleteEventDetails"></a>
DeleteEventDetails</h1>
<p>Deletes all event entries from the history database matching the EventId for one or more HistoricalEventNodes.</p>
<p>If no events are found that match the specified filter for a HistoricalEventNode, the StatusCode for that Node is Bad_NoData.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>NodeId </td><td>NodeId </td><td>Scalar </td><td>NodeId of the object for which history values are to be deleted. </td></tr>
<tr>
<td>EventIds </td><td>ByteString </td><td>Array </td><td>An array of EventIds to identify which events are to be deleted. </td></tr>
</table>
<h1><a class="anchor" id="Doc_OpcUa_HistoryEventFieldList"></a>
HistoryEventFieldList</h1>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEventFieldList_EventFields">EventFields</a> </td><td>Variant </td><td>Array </td><td>List of selected Event fields. <a class="el" href="Doc_OpcUa_HistoricalAccess_DataTypes.html#Doc_OpcUa_HistoryEventFieldList_EventFields">More...</a> </td></tr>
</table>
<h2><a class="anchor" id="Doc_OpcUa_HistoryEventFieldList_EventFields"></a>
EventFields</h2>
<p>List of selected Event fields.</p>
<p>This will be a one to one match with the fields selected in the EventFilter.</p>
<h1><a class="anchor" id="Doc_OpcUa_Annotation"></a>
Annotation</h1>
<p>Describes Annotation information for the history data items.</p>
<table class="doxtable">
<tr>
<th>Field </th><th>DataType </th><th>ValueRank </th><th>Description  </th></tr>
<tr>
<td>Message </td><td>String </td><td>Scalar </td><td>Annotation message or text </td></tr>
<tr>
<td>UserName </td><td>String </td><td>Scalar </td><td>The user that added the Annotation, as supplied by underlying system. </td></tr>
<tr>
<td>AnnotationTime </td><td>DateTime </td><td>Scalar </td><td>The time the Annotation was added. This will probably be different than the SourceTimestamp. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="L1OpcOverview.html">OPC Overview</a></li><li class="navelem"><a class="el" href="Doc_OpcUa_OpcUaInformationModels.html">OPC UA Information Models</a></li><li class="navelem"><a class="el" href="Doc_OpcUa_HistoricalAccess.html">Historical Access</a></li>
    <li class="footer">&copy; Unified Automation GmbH - All rights reserved.</li>
  </ul>
</div>
</body>
</html>
