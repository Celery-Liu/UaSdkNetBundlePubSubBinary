<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>.NET Based OPC UA Client/Server/PubSub SDK: OPC UA NodeId Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header_inner_inner_bg2.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">.NET Based OPC UA Client/Server/PubSub SDK
   &#160;<span id="projectnumber">4.1.0.556</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('L2UaNodeIds.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">OPC UA NodeId Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="UaNodeIdsClassic"></a>
Difference to “Classic” OPC DA</h1>
<p>In the old days the classic DA Server have used simple “string”-Identifiers. The so called “ItemID” was a fully qualified name that was unique throughout the whole server (there was only one “namespace”). Furthermore, the classic DA Servers had only capabilities for a simple hierarchy, i.e. a tree-like structure with branches and leaves. Hence, many vendors have used the full folder hierarchy to create unique ItemIDs (e.g. “Folder1.Folder2.Folder3.MyTemperature”). This lead to massive redundant strings, wasting memory and slowing down performance when looking up or searching for individual Items. With OPC UA, this concept has been abandoned.</p>
<h1><a class="anchor" id="UaNodeIdsConcept"></a>
OPC UA NodeIds</h1>
<p>In OPC UA, every entity in the address space is a node. To uniquely identify a Node, each node has a NodeId that consists of a namespace and an identifier. NodeIds are used to address Nodes in OPC UA Services like Read, Write, Call or CreateMonitoredItems.</p>
<p>The namespace is used to ensure unique NodeIds even if different naming authorities use the same identifiers. This happens if naming authorities work independent of each other like different information model working groups.</p>
<p>The identifier is defined by the naming authority for the namespace. The naming authority can be a standard working group like the OPC UA working group or it could be the local OPC UA Server providing the Nodes. Most standard namespaces define only the identifier for type Nodes like ObjectTypes or DataTypes. Identifiers of instance Nodes like Objects, Variables and Methods are typically defined by the local Server in a dedicated namespace for the Server specific instances. Even if the Server has product or Server specific type Nodes, it is strongly recommended to use own namespaces for type Nodes and instance Nodes.</p>
<p>Identifiers for standard namespaces are known to Clients and Servers. Identifiers for Server defined Nodes are opaque to a Client and a Client cannot make any assumptions about the identifier.</p>
<p>Servers must ensure that NodeIds do not change for Nodes, as long as the Node represents the same information source. Therefore the Server must use logic for identifier creation that ensures that the identifier does not change after a restart of the Server or reconfiguration of the Server.</p>
<p>Clients can get NodeIds through the Services Browse or TranslateBrowsePathsToNodeIds. Browse is typically used by Clients to navigate through the Server address space and to select Nodes and the resulting NodeId of interest. TranslateBrowsePathsToNodeIds is used to get NodeIds of Nodes by following a known path of BrowseNames from a known starting Node. Clients can persist NodeIds of Nodes if necessary, this includes Nodes received through TranslateBrowsePathsToNodeIds.</p>
<p>The NodeId is always composed of three elements:</p>
<dl>
<dt>NamespaceIndex </dt>
<dd>The index an OPC UA server uses for a namespace URI. The namespace URI identifies the naming authority defining the identifiers of NodeIds, e.g. the OPC Foundation, other standard bodies and consortia, the underlying system, the local server. They are stored in the so-called namespace array (also referred to as namespace table). Namespace indexes are numeric values used to identify namespaces to optimize transfer and processing. The namespace index is the index of the namespace URI in the namespace array. </dd>
<dt>IdentifierType </dt>
<dd>The format and data type of the identifier. It can be a numeric value, a string, a globally unique identifier (GUID), or an opaque value (a namespace specific format in a ByteString). Which type is preferred depends on the use case. If it is important to save memory or bandwidth, it makes sense to use numeric NodeIds which are smaller and faster to resolve. The OPC UA namespace as defined by the OPC Foundation uses numeric NodeIds. System-wide and globally unique identifiers allow clients to track Nodes, e.g. work orders, moving between OPC UA servers as they progress through the system.  </dd>
<dt>Identifier </dt>
<dd>The identifier for a node in the address space of an OPC UA server. </dd>
</dl>
<p>Numeric identifiers are most efficient and easy to handle in Client and Server implementations. Numeric identifiers are used if the Nodes are static like Nodes defined by standard working groups. Static Nodes have identical and static Attribute values in all Servers providing the corresponding namespace. Numeric identifiers are also used by Servers with a well known address space like for an embedded OPC UA Server that has a known number of Nodes for data and configuration options. Numeric identifiers cannot be used for namespaces where Nodes are configured dynamically since a Server will not be able to assign unique identifiers due to a limited number of identifiers.</p>
<p>String identifiers provide a simple way to ensure unique identifiers that can be persisted even if nodes are configured dynamically. One option is to use the path as identifier. Another option is to use a Server defined syntax to construct the identifier from Server internal addressing information.</p>
<p>GUID identifiers provide a well defined option to generate unique identifiers, especially if the path to a Node does not change but the Node is logically different. One example is the Object that represents the Session diagnostic where the Client does not change at a reconnect but the Object is logically a different Session after a reconnect.</p>
<p>The following image shows examples for NodeIds having different identifier types.</p>
<div class="image">
<img src="nodeid_concept_1.png" alt="nodeid_concept_1.png"/>
<div class="caption">
Examples for different types of NodeIds</div></div>
 <h1><a class="anchor" id="UaNodeIdsXml"></a>
String Notation</h1>
<p>There is an string notation for NodeIds defined as part of the OPC UA XML Schema which represents a fully qualified NodeId. The format of the string is:</p>
<p><b>ns=&lt;namespaceIndex&gt;;&lt;identifiertype&gt;=&lt;identifier&gt;</b></p>
<p>with the fields</p>
<dl>
<dt>&lt;namespace index&gt; </dt>
<dd>The namespace index formatted as a base 10 number. If the index is 0, then the entire “ns=0;” clause is omitted. </dd>
<dt>&lt;identifier type&gt; </dt>
<dd><p class="startdd">A flag that specifies the identifier type. The flag has the following values:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Identifier Type  </th></tr>
<tr>
<td>i </td><td>NUMERIC (UInteger) </td></tr>
<tr>
<td>s </td><td>STRING (String) </td></tr>
<tr>
<td>g </td><td>GUID (Guid) </td></tr>
<tr>
<td>b </td><td>OPAQUE (ByteString) </td></tr>
</table>
</dd>
<dt>&lt;identifier&gt; </dt>
<dd>The identifier encoded as string. The identifier is formatted using the XML data type mapping for the identifier type. Note that the identifier may contain any non-null UTF8 character including whitespace. </dd>
</dl>
<h2>Examples:</h2>
<dl>
<dt>ns=2;s=MyTemperature </dt>
<dd>namespace index 2, string identifier </dd>
<dt>i=2045 </dt>
<dd>namespace index 0, numeric identifier </dd>
<dt>ns=1;g=09087e75-8e5e-499b-954f-f2a9603db28a </dt>
<dd>namespace index 1, GUID identifier </dd>
<dt>ns=1;b=M/RbKBsRVkePCePcx24oRA==' </dt>
<dd>namespace index 1, Opaque/ByteString identifier </dd>
</dl>
<h1><a class="anchor" id="UaNodeIdsNamespace"></a>
Namespace part of a NodeId</h1>
<p>The identifier part of a NodeId uniquely identifies a node within a namespace, but it is possible that the same identifier is used in different namespaces for different nodes. Hence only the namespace plus the identifier forms a fully qualified identifier (see figure below). This means if a client requests a node, e.g. in a read service, it not only needs the identifier, but also the namespace the node belongs to.</p>
<div class="image">
<img src="nodeid_concept_2.png" alt="nodeid_concept_2.png"/>
<div class="caption">
Nodes with the same identifier in different namespaces</div></div>
<h1><a class="anchor" id="UaNodeIdsNamespaceClient"></a>
Client Namespace Mapping</h1>
<p>In OPC UA service calls the namespace index is used instead of the longer namespace URI in NodeIds. The Client needs to take care of the correct mapping from namespace URI to namespace index. Servers are not allowed to change the namespace index for a specific namespace URI or delete entries from the namespace table as long as an active session exist, so that clients can cache the namespace table for a specific session. But a Server may change namespace indexes and remove entries from the namespace table if no Client is connected or if the server is restarted. For this reason, a Client should not persist the namespace index without storing the namespace URI as well, because a namespace URI represented by index “2” during one session could be represented by index “5” during the next session. Thus, when having established a session with a Server, a Client should always read the Server’s namespace table and update namespace indexes before calling services in which NodeIds are involved.</p>
<p>The following figure shows a typical procedure a Client follows when reading atrributes of a node. In this example, the client wants to read the Node represented by the identifier “MyTemperature” which belongs to the namespace identified by the URI “urn:MyCompany:UaServer:Model2”. The client stores an own namespace table containing the URIs it is interested in to build up fully qualified NodeIds, but doesn’t yet know the corresponding namespace index in the Server namespace table. For being able to access the correct Node, the client has to read the Server namespace table first. The namespace URI “urn:MyCompany:UaServer:Model2” is represented by namespace index “3” on the Server. Now the client is able to update the namespace indexes in its own namespace table and the NodeId it wants to access (in our example this means replacing index “2” with index “3”) and has all information that is needed to access the correct node, in our example “ns=3;s=MyTemperature” in XML notation. As it is allowed that the namespace identified by the URI “urn:MyCompany:UaServer:Model1” also contains a Node having the identifier “MyTemperature”, the client may not even notice that it accessed the wrong node when reading “ns=2;s=MyTemperature”.</p>
<div class="image">
<img src="namespace_table.png" alt="namespace_table.png"/>
<div class="caption">
Reading and storing the namespace table</div></div>
<p> The next chapter describes the <a class="el" href="L2UaSubscription.html">OPC UA Client/Server Subscription Concept</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="L1OpcOverview.html">OPC Overview</a></li><li class="navelem"><a class="el" href="L1OpcUaFundamentals.html">OPC UA Fundamentals</a></li>
    <li class="footer">&copy; Unified Automation GmbH - All rights reserved.</li>
  </ul>
</div>
</body>
</html>
