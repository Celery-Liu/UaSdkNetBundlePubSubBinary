<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>.NET Based OPC UA Client/Server/PubSub SDK: Discovery and Security Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="header_inner_inner_bg2.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">.NET Based OPC UA Client/Server/PubSub SDK
   &#160;<span id="projectnumber">4.1.0.556</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('L2UaDiscoveryConnect.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Discovery and Security Configuration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#DiscoveryConnect_GeneralConcept">General Concept</a></li>
<li class="level1"><a href="#DiscoveryConnect_SecurityPolicies">Security Policies</a></li>
<li class="level1"><a href="#DiscoveryConnect_Certificates">Certificates, Certificate Store and Trust List</a></li>
<li class="level1"><a href="#DiscoveryConnect_ServerInitialConfig">Initial Server Configuration</a><ul><li class="level2"><a href="#DiscoveryConnect_ServerInitialConfig_Endpoints">Endpoints</a></li>
<li class="level2"><a href="#DiscoveryConnect_ServerInitialConfig_DiscoveryServer">Discovery Server</a></li>
</ul>
</li>
<li class="level1"><a href="#DiscoveryConnect_ClientInitialConfig">Initial Client Configuration</a><ul><li class="level2"><a href="#DiscoveryConnect_ClientInitialConfig_EndpointList">List of Server Endpoints</a></li>
</ul>
</li>
<li class="level1"><a href="#DiscoveryConnect_ConnectConfig">Connection Configuration</a></li>
<li class="level1"><a href="#DiscoveryConnect_ReverseConnect">Reverse Connect</a></li>
<li class="level1"><a href="#DiscoveryConnect_Discovery">Discovery</a><ul><li class="level2"><a href="#DiscoveryConnect_Discovery_Local">Local Discovery</a></li>
<li class="level2"><a href="#DiscoveryConnect_Discovery_Multicast">Multicast Subnet Discovery</a></li>
<li class="level2"><a href="#DiscoveryConnect_Discovery_Global">Global Discovery Server</a></li>
</ul>
</li>
<li class="level1"><a href="#DiscoveryConnect_CertificateManagement">Certificate Management with GDS</a></li>
<li class="level1"><a href="#DiscoveryConnect_UserAuthentication">User Authentication</a></li>
<li class="level1"><a href="#DiscoveryConnect_UserAuthorization">User Authorization</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="DiscoveryConnect_GeneralConcept"></a>
General Concept</h1>
<p>To connect to a server, a client needs information like network address, protocol, and security settings. For this purpose, OPC UA defines a set of discovery features.</p>
<p>For the connection between client and server, OPC UA provides different security features for different purpose and for different levels of security:</p><ul>
<li>Application Authentication based on <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_Certificates">Certificates</a></li>
<li>Secure communication channel with message signing and encryption based on <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_SecurityPolicies">Security Policies</a></li>
<li><a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_UserAuthentication">User Authentication</a> based on different user tokens</li>
<li><a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_UserAuthorization">User Authorization</a> based on roles</li>
<li>Access control down to nodes and attributes</li>
<li>Audit mechanisms for connection establishment, Write and Call services</li>
</ul>
<p>All information which is required to establish a connection between client and server is stored in a so-called endpoint. A server can provide several endpoints, each containing</p>
<ul>
<li>Endpoint URL (protocol and network address)</li>
<li>Security Policy (name for a set of security algorithms and key length)</li>
<li>Message Security Mode (security level for exchanged messages)</li>
<li>User Token Type (types of user authentication supported by the server)</li>
</ul>
<p>If several OPC UA servers exist, a Discovery Server can be used to provide information of available servers. Servers can register at the Discovery Server. Clients may then request a list of all available servers from the discovery server and then use the GetEndpoints service to get connection information from a server.</p>
<div class="image">
<img src="discovery_server.png" alt="discovery_server.png"/>
</div>
<p>The initial configuration on client and server side, the different options to find available servers, and the connection establishment between client and server is described in the following sections.</p>
<h1><a class="anchor" id="DiscoveryConnect_SecurityPolicies"></a>
Security Policies</h1>
<p>A Security Policy specifies which security mechanisms are to be used for the Secure Channel between client and server. A SecurityPolicy defines the algorithms for signing and encryption, the algorithm for key derivation and the key lengths used in the algorithms.</p>
<p>A Security Policy is derived from a security profile defined in OPC UA Part 7 - Profiles. The security profiles are regularly updated since specific algorithms may be considered insecure in the future or a key length is not longer secure because of increased compute power.</p>
<p>Therefore each OPC UA profile specification release may add new Security Policies and may deprecate older Security Policies.</p>
<p>OPC UA defines a unique URI for each <em>Security Policies</em>. The following table contains the currently valid Security Policies:</p>
<table class="doxtable">
<tr>
<th>Security Policy</th><th>URI  </th></tr>
<tr>
<td>Aes256_Sha256_RsaPss </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#Aes256_Sha256_RsaPss">http://opcfoundation.org/UA/SecurityPolicy#Aes256_Sha256_RsaPss</a>  </td></tr>
<tr>
<td>Aes128_Sha256_RsaOaep </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#Aes128_Sha256_RsaOaep">http://opcfoundation.org/UA/SecurityPolicy#Aes128_Sha256_RsaOaep</a>  </td></tr>
<tr>
<td>Basic256Sha256 </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256">http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256</a>  </td></tr>
<tr>
<td>None </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#None">http://opcfoundation.org/UA/SecurityPolicy#None</a>  </td></tr>
</table>
<p>The following table contains the already deprecated Security Policies:</p>
<table class="doxtable">
<tr>
<th>Deprecated Security Policy</th><th>URI  </th></tr>
<tr>
<td>Basic256 (Deprecated) </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#Basic256">http://opcfoundation.org/UA/SecurityPolicy#Basic256</a>  </td></tr>
<tr>
<td>Basic128Rsa15 (Deprecated) </td><td><a href="http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15">http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15</a>  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>For security reasons, the Security Policies <em>Basic128Rsa15</em>, <em>Basic256</em> and <em>None</em> should be deactivated by default. It is up to an administrator to enable deprecated Security Policies for backward compatibility but the user must be warned about the deprecated status of these Security Policies.</dd></dl>
<h1><a class="anchor" id="DiscoveryConnect_Certificates"></a>
Certificates, Certificate Store and Trust List</h1>
<p>To identify itself to communication partners, each installed OPC UA application or devices needs an <em>Application Instance Certificate</em> and an associated public/private key pair. The public key is distributed with the certificate. The private key has to remain secret and is used to sign and/or decrypt messages. A communication partner can use the public key to verify the trust relation, check the signature of messages, and encrypt messages. The Application Instance Certificate, including the public and private key, can either be generated by the application or provided by an administrator.</p>
<p>Certificates are filed in a <em>Certificate Store</em>, containing separate locations for trusted and own certificates, as well as certificates from certificate authorities used to verify certificate chains. An additional rejected location may contain certificates of applications that tried to connect but are not trusted yet.</p>
<p>Certificates issued by the application are called self-signed certificates. They are typically generated during installation of the application or at first start. To establish a trust relation between an OPC UA client and server, the self-signed certificates of the communication partner are installed to the trust list. The client certificate is installed to the trust list of the server and the server certificate to the trust list of the client. If the certificate of an application is removed from the trust list, a communication establishment is no longer possible.</p>
<p>Certificates signed by Certificate Authorities (CA) enable central trust management for a group of OPC UA applications or devices. In this case, just the CA certificate must be installed to the trust list of the OPC UA applications. After the CA certificate is installed, all other applications with certificates signed by the CA are able to communicate with each other. To be able to exclude previously trusted applications from the communication, the CA maintains a Certificate Revocation List (CRL). Each installed CA certificate must have an associated, up-to-date CRL installed. This CRL is required for a verification of the trust relation. The OPC UA <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_Discovery_Global">Global Discovery Server</a> definition provides a mechanism for central management of CA signed certificates and update of the corresponding CRLs. CA certificates can build a chain, e.g. a root CA for a company, a CA for a site where the site CA is signed by the root CA and a CA for a production line in the site. An OPC UA application in the production line would only trust the CA for the production line. The other CA certificates are only used to verify the chain.</p>
<p>A file based certificate store contains the following directories. Names and structure may differ between applications.</p>
<dl>
<dt>Own </dt>
<dd>Application Instance Certificate and private key of the application </dd>
<dt>Trusted </dt>
<dd>Self-signed certificates of trusted OPC UA applications or CA certificates for trusted CAs. Each CA certificate comes with a CRL that requires frequent updates. </dd>
<dt>Issuers </dt>
<dd>CA certificates that are not directly trusted but required to verify a chain of CA certificates. Each CA certificate comes with a CRL that requires frequent updates. </dd>
</dl>
<p>In addition, there is typically a Rejected directory where the OPC UA application can store certificates from other OPC UA applications that tried to connect but were not trusted. Administrators can move certificates from Rejected to Trusted if the application is allowed to connect.</p>
<p>As an example, let’s look at a production line where ServerX, ClientY, and ClientZ need to communicate with each other. In the simplest case, a single certificate authority (CaLine1R) manages the central certificate management of the production line (and is thus the root CA). ServerX, ClientY, and ClientZ are all signed by CaLine1R (see figure <a class="el" href="L2UaDiscoveryConnect.html#fig_certificate_authority">below</a>). To trust each other, it’s only necessary to install the certificate and the associated certificate revocation list of CaLine1R.</p>
<p><a class="anchor" id="fig_certificate_authority"></a></p><div class="image">
<img src="certificate_authority.png" alt="certificate_authority.png"/>
<div class="caption">
Certificate Authority</div></div>
<p> In a more complex set-up, e.g. if production line 1 is part of a larger plant consisting of more than one line, itself being part of a company having several production sites, there may be more than one certificate authority, altogether forming a certificate chain (see <a class="el" href="L2UaDiscoveryConnect.html#fig_certificate_chain">figure</a>). CaLine1 is signed by CaPlantA (the production site’s certificate authority), which in turn is signed by CaRoot (the company’s root certificate authority). Each of these CAs keeps its own certificate revocation list.</p>
<p><a class="anchor" id="fig_certificate_chain"></a></p><div class="image">
<img src="certificate_chain.png" alt="certificate_chain.png"/>
<div class="caption">
Certificate Chain</div></div>
<p> The following <a class="el" href="L2UaDiscoveryConnect.html#fig_certificate_store_clientx">figure</a> exemplarily shows the content of a file based certificate store for ClientX in the above mentioned scenarios. In both cases, the directories <em>own</em> look identical: The subfolder <em>certs</em> contains the client’s own certificate <em>ClientX.der</em> and <em>private</em> contains the private key <em>ClientX.pem</em>.</p>
<p>The content of the folders <em>trusted</em> is similar in both cases: <em>certs</em> contains the certificate of the trusted certificate authority (i.e. the CA signing the applications to trust): <em>CaLine1R.der</em> in the simple case without certificate chain, and <em>CaLine1.der</em> in the more complex case. The associated certificate revocation list <em>CaLine1R.crl</em> (simple case) or <em>CaLine1.crl</em> (certificate chain example) has to be placed into the subfolder <em>crl</em>.</p>
<p>If there’s no certificate chain, the folder <em>issuers</em> remains empty. If there is a certificate chain, <em>issuers</em> has to contain all certificates needed to validate the complete chain in the subfolder <em>certs</em>, and one and only one certificate revocation list for each certificate authority in the folder <em>crl</em>. In our example above, we have two superordinate certificate authorities: CaPlantA and CaRoot. Thus, the folder <em>certs</em> contains the certificates <em>CaPlantA.der</em> and <em>CaRoot.der</em>, and the folder <em>crl</em> contains the certificate revocation lists <em>CaPlantA.crl</em> and <em>CaRoot.crl</em>.</p>
<p><a class="anchor" id="fig_certificate_store_clientx"></a></p><div class="image">
<img src="certificate_store_clientx.png" alt="certificate_store_clientx.png"/>
<div class="caption">
Certificate Store Configuration for ClientX with Certificate Chain (top) and without (bottom)</div></div>
 <h1><a class="anchor" id="DiscoveryConnect_ServerInitialConfig"></a>
Initial Server Configuration</h1>
<p>The following figure shows the initial configuration of a server after installation.</p>
<div class="image">
<img src="server_initial_config.png" alt="server_initial_config.png"/>
</div>
<p>The configuration consists of</p><ul>
<li>an application instance certificate identifying the server installation</li>
<li>a certificate store, including a list of trusted and rejected application instance certificates</li>
<li>at least one endpoint (<a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_ServerInitialConfig_Endpoints">see below</a>)</li>
</ul>
<h2><a class="anchor" id="DiscoveryConnect_ServerInitialConfig_Endpoints"></a>
Endpoints</h2>
<p>A server has to provide (at least one) endpoint(s) where clients can connect to. A client uses the Discovery URL (normally identical to the Endpoint URL) to request the list of endpoints including the security configuration from a server. This request through the GetEndpoints service always works without security. The Discovery URL is normally provided by Discovery servers.</p>
<p>The <em>Endpoint URL</em> provides the basic information that clients need to connect to a server, including the protocol, the host name or IP address, and the port number, e.g. opc.tcp://localhost:48020. In addition, the client needs to know the following security options configured on the server.</p>
<p>The <em>Security Policy</em> defines the algorithms and key length used by the client to establish a Secure Channel with the server. See <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_SecurityPolicies">Security Policy above</a> for more details on the available <em>Security Policies</em>.</p>
<p>The <em>Message Security Mode</em> configures the general level of security applied to messages exchanged between client and server. Three <em>Message Security Modes</em> are defined:</p>
<dl>
<dt>None </dt>
<dd>No security is applied. </dd>
<dt>Sign </dt>
<dd>All messages are signed but not encrypted. </dd>
<dt>Sign&amp;Encrypt </dt>
<dd>All messages are signed and encrypted. </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For security reasons, the Security Policies <em>Basic128Rsa15</em>, <em>Basic256</em> and <em>None</em> as well as the Message Security Mode <em>None</em> should be deactivated by default.</dd></dl>
<p>OPC UA supports the following <em>User Identity Token Types</em></p>
<dl>
<dt>Anonymous Identity Token </dt>
<dd>No user information is available. </dd>
<dt>Username Identity Token </dt>
<dd>A user identified by user name and password. </dd>
<dt>X.509 Identity Token </dt>
<dd>A user identified by an X509v3 Certificate. </dd>
<dt>Issued Identity Token </dt>
<dd>A user identified by a JSON Web Token (JWT). </dd>
</dl>
<p>A typical set of endpoints could be:</p>
<table class="doxtable">
<tr>
<th>Endpoint 1</th><th>Endpoint 2  </th></tr>
<tr>
<td><dl>
<dt>Endpoint URL </dt>
<dd>opc.tcp://MyServer:48001 </dd>
<dt>Security Policy </dt>
<dd>Basic256 </dd>
<dt>Message Security Mode </dt>
<dd>Sign, SignAndEncrypt </dd>
<dt>User Token Type </dt>
<dd>Username, X.509 </dd>
</dl>
</td><td><dl>
<dt>Endpoint URL </dt>
<dd>opc.tcp://MyServer:48001 </dd>
<dt>Security Policy </dt>
<dd>Basic256Sha256 </dd>
<dt>Message Security Mode </dt>
<dd>Sign, SignAndEncrypt </dd>
<dt>User Token Type </dt>
<dd>Username </dd>
</dl>
</td></tr>
</table>
<h2><a class="anchor" id="DiscoveryConnect_ServerInitialConfig_DiscoveryServer"></a>
Discovery Server</h2>
<p>Servers may register at so-called Discovery Servers so that they can be discovered by clients. The registration process is described further on for the different Discovery options.</p>
<p>A Local Discovery Server (LDS) on a network node is only necessary if more than one OPC UA server is available, e.g. on a Windows PC with several OPC UA servers installed. In this case, the LDS is listening on port 4840, which is the IANA registered port for OPC UA. OPC UA clients start the discovery process with FindServers using this port.</p>
<p>OPC UA servers on devices or other systems with just one server use port 4840 directly. There is no need for a LDS in this case. Every OPC UA server implements the FindServers service returning itself.</p>
<h1><a class="anchor" id="DiscoveryConnect_ClientInitialConfig"></a>
Initial Client Configuration</h1>
<p>The following figure shows the initial configuration of a client after installation:</p>
<div class="image">
<img src="client_initial_config.png" alt="client_initial_config.png"/>
</div>
<p>The configuration consists of</p><ul>
<li>an application instance certificate to identify the client application</li>
<li>a certificate store, including a list of trusted certificates</li>
<li>list of server endpoints (<a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_ClientInitialConfig_EndpointList">see below</a>)</li>
</ul>
<h2><a class="anchor" id="DiscoveryConnect_ClientInitialConfig_EndpointList"></a>
List of Server Endpoints</h2>
<p>A client can find servers using the different <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_Discovery">Discovery</a> options and retrieve the information it needs to connect to a server via the OPC UA service GetEndpoints. To avoid having to repeat this Discovery process before each connection attempt, most clients will store the server endpoint information for a configured server.</p>
<h1><a class="anchor" id="DiscoveryConnect_ConnectConfig"></a>
Connection Configuration</h1>
<p>Once a client has found the server it intends to connect to, the client is able to call GetEndpoints. The server returns a list of endpoints it provides, including the security configuration (see <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_GeneralConcept">above</a>) as well as its certificate (including the server’s public key).</p>
<div class="image">
<img src="get_endpoints.png" alt="get_endpoints.png"/>
</div>
<p>For being able to establish a secure connection to the server, the client has to trust the server’s certificate, i.e. the certificate has to be added to the trust list. Usually, a dialog window will open and prompt the user to examine the certificate and decide whether it should be trusted.</p>
<p>The following screenshot shows the respective dialog window in UaExpert when trying to connect to a server for the first time. It displays the content of the server’s certificate and allows the user to decide whether to trust the certificate or not. If the user chooses “Trust Server Certificate”, it is stored in the folder <em>trusted/certs</em> in UaExpert’s PKI certificate store.</p>
<div class="image">
<img src="expert_server_certificate_scaled.png" alt="expert_server_certificate_scaled.png"/>
</div>
<p>Having trusted the certificate, the client is able to check the signature of messages from the server and encrypt messages to be sent to the server. After saving the endpoints to the server connection list, the client configuration is finished.</p>
<div class="image">
<img src="client_configured.png" alt="client_configured.png"/>
</div>
<p>Now the client can attempt to create a secure channel with the server, sending along its Application Instance Certificate (including the public key of the client). This first connection attempt will be rejected, because the server doesn’t trust the client yet.</p>
<div class="image">
<img src="create_secure_channel.png" alt="create_secure_channel.png"/>
</div>
<p>Trusting the client’s certificate is a manual step on the server. Usually, a server administrator has to move the client certificate from the list of rejected to the list of trusted certificates.</p>
<div class="image">
<img src="client_certificate_rejected.png" alt="client_certificate_rejected.png"/>
</div>
<p>When using the C++ SDK Demo Server, this can be done using the administration tool as shown in the following screenshot. The “Certificates” tab lists the certificates in the server’s Certificate Store. Certificates from the <em>Trusted</em> directory are shown as trusted and the certificates from the <em>Rejected</em> directory are shown as untrusted. UaExpert’s certificate is shown as “Untrusted”. Right clicking on the certificate and choosing “Trust” from the context menu moves the certificate from the folder <em>rejected</em> to <em>trusted/certs</em> in the server’s Certificate Store.</p>
<div class="image">
<img src="admin_dialog_trust_certificate_scaled.png" alt="admin_dialog_trust_certificate_scaled.png"/>
</div>
<p>After this step, the server is configured.</p>
<div class="image">
<img src="server_configured.png" alt="server_configured.png"/>
</div>
<p>The next attempt of the client to create a secure channel will succeed, and it is able to create and activate a session with the server.</p>
<div class="image">
<img src="secure_connection.png" alt="secure_connection.png"/>
</div>
<h1><a class="anchor" id="DiscoveryConnect_ReverseConnect"></a>
Reverse Connect</h1>
<p>The creation of a secure channel includes a TCP/IP connection establishment from client to server. In this case the server opens a port that is used by the client to create the TCP/IP connection.</p>
<p>OPC UA provides also a Reverse Connect capability where client opens a port and the TCP/IP connection is created by server to the client. After this initial TCP/IP connection establishment, the client creates the secure channel and the session the same way as for the normal connect.</p>
<p>For this case the server needs to know the clients that want to connect and must try to establish the TCP/IP connections to allow the clients to complete the secure channel and session establishment. All further actions after the initial TCP/IP connect are initiated by the client. This includes the connection monitoring.</p>
<h1><a class="anchor" id="DiscoveryConnect_Discovery"></a>
Discovery</h1>
<p>Before a client can connect to a server, it needs to collect information. Therefore, OPC UA defines three different discovery options:</p>
<ul>
<li>Local Discovery</li>
<li>Multicast Subnet Discovery</li>
<li>Global Discovery</li>
</ul>
<h2><a class="anchor" id="DiscoveryConnect_Discovery_Local"></a>
Local Discovery</h2>
<p>If a client does know that there are OPC UA servers running on a certain host, but doesn’t have detailed connection information, it can construct a connection URL from the host name and the standard OPC UA port 4840 (e.g. opc.tcp://localhost:4840 or opc.tcp://targetHost:4840). This URL is then used to connect to the discovery server and to call FindServers.</p>
<p>If more than one OPC UA server is installed on a system, a Local Discovery Server (LDS) is running on port 4840. The LDS maintains a list of available servers which may be used by servers to announce their existence to clients.</p>
<p>To be visible for local discovery, servers have to register at the LDS using either the RegisterServer2 or the RegisterServer service. The registration with the LDS requires security configuration. Therefore, the server certificate must be installed in the trust list of the LDS.</p>
<div class="image">
<img src="local_discovery.png" alt="local_discovery.png"/>
</div>
<p>If only one server is installed, a separate LDS is not necessary and the server itself will use the port 4840 and will respond to FindServers returning itself.</p>
<h2><a class="anchor" id="DiscoveryConnect_Discovery_Multicast"></a>
Multicast Subnet Discovery</h2>
<p>For situations where the client doesn’t know the available servers on the network, OPC UA defines the use of mDNS, a standardized multicast extension to DNS also known as zeroconf. mDNS defines mechanisms for name resolution without a central DNS server as well as service discovery functionality. This ad-hoc discovery typically works only within a subnet.</p>
<p>For regular OPC UA applications, the functionality is provided by Local Discovery Servers with multicast extension (LDS-ME). Servers registered with the LDS are automatically announced via LDS-ME. Servers registered with RegisterServer2 can also provide a list of server capabilities that can be used for filtering the list of available servers.</p>
<p>Another feature of an LDS-ME is the creation of a local cache with OPC UA servers announced via mDNS.</p>
<p>Clients can retrieve this list by calling the service FindServersOnNetwork on the local LDS-ME.</p>
<div class="image">
<img src="multicastsubnet_discovery.png" alt="multicastsubnet_discovery.png"/>
</div>
<h2><a class="anchor" id="DiscoveryConnect_Discovery_Global"></a>
Global Discovery Server</h2>
<p>The OPC UA Global Discovery Server (GDS) concept allows the configuration of a network wide discovery of OPC UA servers that is not limited to a subnet like mDNS. In addition, it provides functionality for central certificate management including the distribution of CA signed certificates and related Certificate Revocation Lists (CRL). A GDS is a complete OPC UA Server and therefore provides the only secure discovery option.</p>
<p>For the discovery functionality, OPC UA servers must be registered as application with the GDS when they are installed within the network. The registration requires security and administrative rights on the GDS.</p>
<p>OPC UA clients can query the GDS for available servers using different filter options (like capability filter of a string pattern matching on product or application URIs).</p>
<div class="image">
<img src="gds_simple.png" alt="gds_simple.png"/>
</div>
<p>If the GDS is registered at different LDS-MEs in different subnets, the GDS can be found by clients using FindServersOnNetwork on the local LDS-ME.</p>
<div class="image">
<img src="gds_ldsme.png" alt="gds_ldsme.png"/>
</div>
<h1><a class="anchor" id="DiscoveryConnect_CertificateManagement"></a>
Certificate Management with GDS</h1>
<p>OPC UA applications registered with a GDS can use the GDS also for central certificate management.</p>
<p>The GDS can manage self-signed certificates, but the main use case is the management of a Certificate Authority (CA), the generation of CA signed Application Instance Certificates, and the distribution of the CA related Certificate Revocation Lists (CRL). More details regarding Certificates can be found in <a class="el" href="L2UaDiscoveryConnect.html#DiscoveryConnect_Certificates">Certificates, Certificate Store and Trust List</a>.</p>
<p>The OPC UA interface DirectoryType provides application registration and discovery functionality. The OPC UA interface CertificateDirectoryType of the GDS encapsulates a CA or the communication with the CA and the related certificate management functionality.</p>
<p>The certificate management includes</p><ul>
<li>the initial set-up of an Application Instance Certificate</li>
<li>regular updates of the trust list and CA related Certificate Revocation Lists</li>
<li>renewal of Application Instance Certificates</li>
</ul>
<div class="image">
<img src="gds_application_setup.png" alt="gds_application_setup.png"/>
</div>
<p>The initial application set-up requires administrative rights. The first step is the registration of the client or server applications using DirectoryType::RegisterApplication. Registered servers are returned in calls to DirectoryType::QueryServers.</p>
<p>The second step is the creation of a CA signed certificate. A call to CertificateDirectoryType::StartSigningRequest is used to send a certificate signing request to the CA. With this method, the private key is kept in the client and server application and is only used to sign the request. The CA uses the request to create and sign the public key. An alternative is the creation of a private and a public key using the method CertificateDirectoryType::StartNewKeyPairRequest. After the request is processed by the GDS, the new certificate can be used by the OPC UA application. The initial set-up also includes the initial transfer of the trust list for the application from the GDS to the application.</p>
<div class="image">
<img src="gds_pull.png" alt="gds_pull.png"/>
</div>
<p>Since a CA can revoke certificates, the application trust lists and the CA related Certificate Revocation Lists (CRL) must be updated frequently. If the OPC UA application is a client or a server with client functionality, the OPC UA application can use CertificateDirectoryType::GetTrustList to request the latest trust list and CRLs from the GDS OPC UA server.</p>
<p>This update model is called Pull Certificate Management.</p>
<div class="image">
<img src="gds_push.png" alt="gds_push.png"/>
</div>
<p>For OPC UA servers without client functionality, the GDS concept defines also a server side interface called ServerConfigurationType. It allows the management of the server certificate and the trust list through a standard interface. The management is done through a GDS client that connects to the GDS on behalf of the server to manage and update the server through the ServerConfiguration object.</p>
<p>This update model is called Push Certificate Management.</p>
<p>The ServerConfiguration object enables also remote certificate management without a GDS by using tools like UaExpert.</p>
<p>All certificate management related functionality requires administrative rights and encrypted communication channels.</p>
<h1><a class="anchor" id="DiscoveryConnect_UserAuthentication"></a>
User Authentication</h1>
<p>User authentication allows the server to verify the identity of the client user credentials. The user credentials are passed as User Identity Token in the Service ActivateSession</p>
<p>OPC UA supports the following <em>User Identity Token Types</em></p>
<dl>
<dt>Anonymous Identity Token </dt>
<dd>No user information is available. </dd>
<dt>Username Identity Token </dt>
<dd>A user identified by user name and password. </dd>
<dt>X.509 Identity Token </dt>
<dd>A user identified by an X509v3 Certificate. </dd>
<dt>Issued Identity Token </dt>
<dd>A user identified by a JSON Web Token (JWT). </dd>
</dl>
<div class="image">
<img src="user_authentication.png" alt="user_authentication.png"/>
</div>
<p>The client shall always prove possession of a User Identity Token when it passes it to the server in ActivateSession.</p>
<p>The Username Identity Token includes a password as secret which the server will accept as proof.</p>
<p>X.509 Identity Tokens allow the client to create a signature with the secret associated with the token. In this cases, the client proves possession of a User Identity Token by creating a signature with the secret (private key) and passing the signature to the server.</p>
<p>The Issued Identity Token is used to pass security tokens issued by an external authorization service to the server. The standard option for Issued Identity Tokens are JSON Web Tokens (JWT). The external authorization service authorizes the client and user credentials for the server. If the access to the server is granted, the external authorization service creates a token and a signature for the token. The server uses the signature contained in the JWT to validate the token. The token must be treated as secret.</p>
<p>In order to protect tokens that contain a secret these tokens are encrypted before they are passed to the server.</p>
<p>After checking the user credentials, the server verifies if the user is allowed to create a session with the server. This can be done with a user data base in the case of Username Identity Token or X.509 Identity Token or by trusting the verification of an external authorization service for the Issued Identity Token.</p>
<h1><a class="anchor" id="DiscoveryConnect_UserAuthorization"></a>
User Authorization</h1>
<p>A role is a function assumed by a client when it accesses a server. Roles are used to separate authentication (determining who a client is) from authorization (determining what the Client is allowed to do). By separating these tasks servers can allow centralized services to manage user identities and credentials while the server manages the permissions on its nodes for roles. But even if the mapping of users to roles is done in the server, the management of permissions for the nodes can be separated from the management of users and the assignment of users to roles.</p>
<div class="image">
<img src="user_authorization1.png" alt="user_authorization1.png"/>
</div>
<p>When a Session is created, the server must determine what roles are granted to that Session. OPC UA defines standard mapping rules which servers may support. Servers may also use vendor specific mapping rules in addition to or instead of the standard rules.</p>
<p>The standard mapping rules allow Roles to be granted based on:</p><ul>
<li>User identity</li>
<li>Application identity</li>
<li>Endpoint used to connect</li>
</ul>
<p>User identity mappings can be based on user names, user certificates or roles in an Issued Identity Token.</p>
<p>Application identity mappings are based on the ApplicationUri specified in the client certificate.</p>
<p>OPC UA defines the following well known roles. A server can define additional roles.</p>
<table class="doxtable">
<tr>
<th>Standard Role</th><th>Description  </th></tr>
<tr>
<td>Anonymous </td><td>The role has very limited access for use when a Session has anonymous credentials.  </td></tr>
<tr>
<td>AuthenticatedUser </td><td>The Role has limited access for use when a Session has valid non-anonymous credentials but has not been explicitly granted access to a specific role.  </td></tr>
<tr>
<td>Observer </td><td>The role is typically allowed to browse, read live data, read historical data/events or subscribe to data/events.  </td></tr>
<tr>
<td>Operator </td><td>The role is typically allowed to browse, read live data, read historical data/events or subscribe to data/events. In addition, the Session is allowed to write some live data and call some Methods.  </td></tr>
<tr>
<td>Engineer </td><td>The role is typically allowed to browse, read/write configuration data, read historical data/events, call Methods or subscribe to data/events.  </td></tr>
<tr>
<td>Supervisor </td><td>The role is typically allowed to browse, read live data, read historical data/events, call Methods or subscribe to data/events.  </td></tr>
<tr>
<td>ConfigureAdmin </td><td>The role is allowed to change the non-security related configuration settings.  </td></tr>
<tr>
<td>SecurityAdmin </td><td>The role is allowed to change security related settings.  </td></tr>
</table>
<p>OPC UA defines also a standard access control mechanism for nodes called RolePermission. A RolePermission defines the permissions mask for a role. The permission mask defines the access to attributes of the Node or the Service specific access to Nodes.</p>
<p>The following table shows example RolePermissions for the Node in the following figure.</p>
<table class="doxtable">
<tr>
<th>Role</th><th>Permissions  </th></tr>
<tr>
<td>Observer </td><td>Browse, Read  </td></tr>
<tr>
<td>Operator </td><td>Browse, Read, Write  </td></tr>
</table>
<div class="image">
<img src="user_authorization2.png" alt="user_authorization2.png"/>
</div>
<p>The attribute RolePermissions is only readable for security administrators. It contains the list of RolePermissions for the Node. If the attribute is writable, the security administrator is able to change the RolePermissions.</p>
<p>For some attributes like UserAccessLevel, the attribute value depends on the role permissions.</p>
<p>The following table provides the list of permission masks.</p>
<table class="doxtable">
<tr>
<th>Permission</th><th>Description  </th></tr>
<tr>
<td>Browse </td><td>The client is allowed to see the references to and from the Node. This implies that the client is able to Read to attributes other than the Value or the RolePermissions attribute.  </td></tr>
<tr>
<td>Read </td><td>The client is allowed to read the Value attribute. This bit affects the CurrentRead bit of the UserAccessLevel attribute.  </td></tr>
<tr>
<td>Write </td><td>The client is allowed to write the Value attribute. This bit affects the CurrentWrite bit of the UserAccessLevel attribute.  </td></tr>
<tr>
<td>Call </td><td>The client is allowed to call the Method if this bit is set on the Object or ObjectType Node passed in the Call request and the Method Instance associated with that Object or ObjectType. This bit affects the UserExecutable attribute when set on Method Node.  </td></tr>
<tr>
<td>WriteHistorizing </td><td>The client is allowed to write to the Historizing attributes if the WriteMask indicates that the Attribute is writeable. This bit affects the value of the UserWriteMask attribute.  </td></tr>
<tr>
<td>WriteAttribute </td><td>The client is allowed to write to attributes other than the Value, Historizing or RolePermissions attribute if the WriteMask indicates that the attribute is writeable. This bit affects the value of a UserWriteMask attribute.  </td></tr>
<tr>
<td>ReadRolePermissions </td><td>The client is allowed to read the RolePermissions attribute.  </td></tr>
<tr>
<td>WriteRolePermissions </td><td>The client is allowed to write to the RolePermissions attribute if the WriteMask indicates that the attribute is writeable. This bit affects the value of the UserWriteMask attribute.  </td></tr>
<tr>
<td>ReadHistory </td><td>The client is allowed to read the history associated with a Node. This bit affects the HistoryRead bit of the UserAccessLevel attribute.  </td></tr>
<tr>
<td>InsertHistory </td><td>The client is allowed to insert the history associated with a Node.  </td></tr>
<tr>
<td>ModifyHistory </td><td>The client is allowed to modify the history associated with a Node.  </td></tr>
<tr>
<td>DeleteHistory </td><td>The client is allowed to delete the history associated with a Node.  </td></tr>
<tr>
<td>ReceiveEvents </td><td>A client only receives an Event if this bit is set on the Node identified by the EventTypeId field and on the Node identified by the SourceNode field.  </td></tr>
<tr>
<td>AddReference </td><td>The client is allowed to add references to the Node.  </td></tr>
<tr>
<td>RemoveReference </td><td>The client is allowed to remove references from the Node.  </td></tr>
<tr>
<td>DeleteNode </td><td>The client is allowed to delete the Node.  </td></tr>
<tr>
<td>AddNode </td><td>The client is allowed to add Nodes to the Namespace.  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="L1OpcOverview.html">OPC Overview</a></li><li class="navelem"><a class="el" href="L1OpcUaFundamentals.html">OPC UA Fundamentals</a></li>
    <li class="footer">&copy; Unified Automation GmbH - All rights reserved.</li>
  </ul>
</div>
</body>
</html>
